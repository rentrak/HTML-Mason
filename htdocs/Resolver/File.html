<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>HTML::Mason::Resolver::File - Component path resolver for file-based components</title>
<link rev="made" href="mailto:root@localhost" />
</head>

<body style="background-color: white">

<p><A NAME="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><A HREF="#name">NAME</a></li>
	<li><A HREF="#synopsis">SYNOPSIS</a></li>
	<li><A HREF="#description">DESCRIPTION</a></li>
	<li><A HREF="#parameters_to_the_new___construc">PARAMETERS TO THE <code>new()</code> CONSTRUCTOR</a></li>
	<li><A HREF="#additional_methods">ADDITIONAL METHODS</a></li>
	<li><A HREF="#see_also">SEE ALSO</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<h1><A NAME="name">NAME</a></h1>
<p>HTML::Mason::Resolver::File - Component path resolver for file-based components</p>
<p>
</p>
<hr />
<h1><A NAME="synopsis">SYNOPSIS</a></h1>
<pre>
  my $resolver = HTML::Mason::Resolver::File-&gt;new( comp_root =&gt; '/var/www/mason' );</pre>
<pre>
  my $info = $resolver-&gt;get_info('/some/comp.html');
  my $comp_root = $resolver-&gt;comp_root;</pre>
<p>
</p>
<hr />
<h1><A NAME="description">DESCRIPTION</a></h1>
<p>This HTML::Mason::Resolver subclass is used when components are stored
on the filesystem, which is the norm for most Mason-based applications.</p>
<p>
</p>
<hr />
<h1><A NAME="parameters_to_the_new___construc">PARAMETERS TO THE <code>new()</code> CONSTRUCTOR</a></h1>
<p>The <code>new</code> method takes a single parameter, <A HREF="#item_comp_root"><code>comp_root</code></a>.</p>
<dl>
<dt><strong><A NAME="item_comp_root">comp_root</a></strong><br />
</dt>
<dd>
The component root marks the top of your component hierarchy and
defines how component paths are translated into real file paths. For
example, if your component root is <em>/usr/local/httpd/docs</em>, a component
path of <em>/products/index.html</em> translates to the file
<em>/usr/local/httpd/docs/products/index.html</em>.
</dd>
<dd>
<p>Under <a HREF="../ApacheHandler.html">Apache</a> and
<a HREF="../CGIHandler.html">CGI</a>, comp_root defaults to the server's
document root. In standalone mode comp_root defaults to the current
working directory.</p>
</dd>
<dd>
<p>This parameter may be either a scalar or an array reference.  If it is
a scalar, it should be a filesystem path indicating the component
root. If it is an array reference, it should be of the following form:</p>
</dd>
<dd>
<pre>
 [ [ key1 =&gt; '/path/to/root' ],
   [ key2 =&gt; '/path/to/other/root' ] ]</pre>
</dd>
<dd>
<p>The ``keys'' for each path must be unique names and their ``values'' must
be filesystem paths.  These paths will be searched in the provided
order whenever a component path must be resolved to a filesystem path.</p>
</dd>
<dd>
<p>If no component root is specified, the current working directory is
used.</p>
</dd>
<p></p></dl>
<p>
</p>
<hr />
<h1><A NAME="additional_methods">ADDITIONAL METHODS</a></h1>
<dl>
<dt><strong>comp_root</strong><br />
</dt>
<dd>
This method returns the component root, which will either be a scalar
or an array reference, as documented <A HREF="../Resolver/File.html#item_comp_root">here</a>.
</dd>
<p></p>
<dt><strong><A NAME="item_comp_root_array">comp_root_array</a></strong><br />
</dt>
<dd>
Returns the component root as an array of name/path pairs.  Can be
used like the following:
</dd>
<dd>
<pre>
  foreach my $pair ($self-&gt;comp_root_array) {
    my ($name, $path) = @$pair;
    ...
  }</pre>
</dd>
<p></p></dl>
<p>
</p>
<hr />
<h1><A NAME="see_also">SEE ALSO</a></h1>
<p><a HREF="../Mason.html">HTML::Mason</a></p>

</body>

</html>
