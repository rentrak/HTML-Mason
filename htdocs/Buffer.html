<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>HTML::Mason::Buffer - Objects for Handling Component Output</title>
<link rev="made" href="mailto:root@localhost" />
</head>

<body style="background-color: white">

<p><A NAME="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><A HREF="#name">NAME</a></li>
	<li><A HREF="#synopsis">SYNOPSIS</a></li>
	<li><A HREF="#description">DESCRIPTION</a></li>
	<li><A HREF="#constructor">CONSTRUCTOR</a></li>
	<li><A HREF="#methods">METHODS</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<h1><A NAME="name">NAME</a></h1>
<p>HTML::Mason::Buffer - Objects for Handling Component Output</p>
<p>
</p>
<hr />
<h1><A NAME="synopsis">SYNOPSIS</a></h1>
<pre>
  my $buffer = HTML::Mason::Buffer-&gt;new( sink =&gt; sub { print @_ } );</pre>
<pre>
  my $child = $buffer-&gt;new_child;</pre>
<pre>
  $child-&gt;receive( 'foo', 'bar' );</pre>
<p>
</p>
<hr />
<h1><A NAME="description">DESCRIPTION</a></h1>
<p>Mason's buffer objects handle all output generated by components.
They are used to implement <code>&lt;%filter&gt;</code> blocks, the <code>$m-&gt;scomp</code>
method, the <code>store</code> component call modifier, and content-filtering
component feature.</p>
<p>Buffers can either store output in a scalar, internally, or they can
be given a callback to call immediately when output is generated.</p>
<p>Most users will never have to deal with buffer objects directly, but
will instead use Request object methods such as <code>print</code> or
<code>clear_buffer</code>.</p>
<p>
</p>
<hr />
<h1><A NAME="constructor">CONSTRUCTOR</a></h1>
<p>Buffer objects can be constructed in two different ways.  Like any
other Mason object, they can be created via their <code>new</code> method.</p>
<p>This method takes several parameters, all of them optional.</p>
<dl>
<dt><strong><A NAME="item_sink">sink</a></strong><br />
</dt>
<dd>
This should be either a subroutine reference or a scalar reference.
</dd>
<dd>
<p>If this is a subroutine reference, then any output received by the
buffer will be passed to this subroutine reference as a list of one or
more items.</p>
</dd>
<dd>
<p>If this is a scalar reference, then data will be concatenated onto
this scalar as it is received.</p>
</dd>
<dd>
<p>If no parameter is given, then output will be buffered internally, to
be retrieved by the <A HREF="#item_output"><code>output</code></a> method.</p>
</dd>
<p></p>
<dt><strong><A NAME="item_ignore_flush">ignore_flush</a></strong><br />
</dt>
<dd>
If this parameter is true, then the created buffer will ignore calls
to its <A HREF="#item_flush"><code>flush</code></a> method.  This parameter defaults to true for buffers
created via the <code>new</code> method, and false for those created via the
<code>new_child</code> method.
</dd>
<p></p>
<dt><strong><A NAME="item_filter">filter</a></strong><br />
</dt>
<dd>
This parameter should be a subroutine reference which should expect to
receive a single argument, the output to be filtered.  It should
return the output after transforming it in any way it desires.
</dd>
<p></p></dl>
<p>New buffers can also be created via the <code>new_child</code> method, which
takes the same parameters as the <code>new</code> method.  The <code>new_child</code>
method is an <em>object</em> method, not a class method.</p>
<p>It creates a new buffer object which will eventually pass its output
to the buffer object that created it.</p>
<p>This allows you to create a stack of buffers.</p>
<p>
</p>
<hr />
<h1><A NAME="methods">METHODS</a></h1>
<dl>
<dt><strong><A NAME="item_receive">receive</a></strong><br />
</dt>
<dd>
This method takes a list of items to be sent to the buffer's sink.
</dd>
<p></p>
<dt><strong><A NAME="item_flush">flush</a></strong><br />
</dt>
<dd>
This method tells the buffer to pass any output it may currently have
stored internally to its parent, if it has one.  It then clears the
buffer.
</dd>
<dd>
<p>This method does nothing if the buffer does not have any stored
output, which is the case for buffers that were given a subroutine
reference as their <A HREF="#item_sink"><code>sink</code></a> argument.</p>
</dd>
<p></p>
<dt><strong><A NAME="item_clear">clear</a></strong><br />
</dt>
<dd>
For buffers which store output internally, this clears any pending
output.
</dd>
<p></p>
<dt><strong><A NAME="item_output">output</a></strong><br />
</dt>
<dd>
For buffers which store output internally, this returns any pending
output, possibly passing it through a buffer's filter, if it has one.
This does <strong>not</strong> clear the buffer.
</dd>
<p></p></dl>

</body>

</html>
