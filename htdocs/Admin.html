    <HTML> 
	<HEAD> 
	    <TITLE>HTML::Mason::Admin - Mason Administrator's Guide

</TITLE> 
	</HEAD>

	<BODY>

<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#name">NAME</A>
	<LI><A HREF="#description">DESCRIPTION</A>
	<LI><A HREF="#global_settings">GLOBAL SETTINGS</A>
	<LI><A HREF="#site_configuration_methods">SITE CONFIGURATION METHODS</A>
	<LI><A HREF="#minimal_configuration">MINIMAL CONFIGURATION</A>
	<LI><A HREF="#configuration_via_httpd_conf_dir">CONFIGURATION VIA httpd.conf DIRECTIVES</A>
	<UL>

		<LI><A HREF="#parser_parameters">Parser Parameters</A>
		<LI><A HREF="#interp_parameters">Interp Parameters</A>
		<LI><A HREF="#apachehandler_parameters">ApacheHandler Parameters</A>
		<LI><A HREF="#special_parameters">Special Parameters</A>
		<LI><A HREF="#memory_usage">Memory Usage</A>
	</UL>

	<LI><A HREF="#configuring_via_a_handler_script">CONFIGURING VIA A HANDLER SCRIPT</A>
	<UL>

		<LI><A HREF="#creating_the_mason_objects">Creating the Mason objects</A>
		<LI><A HREF="#multiple_component_roots">Multiple component roots</A>
		<LI><A HREF="#external_modules">External modules</A>
		<LI><A HREF="#file_ownership">File ownership</A>
		<LI><A HREF="#persistent_user_sessions">Persistent user sessions</A>
		<LI><A HREF="#using_global_variables">Using global variables</A>
		<LI><A HREF="#declining_image_requests">Declining image requests</A>
		<LI><A HREF="#securing_top_level_components">Securing top-level components</A>
		<LI><A HREF="#allowing_directory_requests">Allowing directory requests</A>
	</UL>

	<LI><A HREF="#standard_features">STANDARD FEATURES</A>
	<UL>

		<LI><A HREF="#data_caching">Data caching</A>
		<LI><A HREF="#debugging">Debugging</A>
		<LI><A HREF="#previewer">Previewer</A>
		<LI><A HREF="#system_logs">System logs</A>
	</UL>

	<LI><A HREF="#performance_tuning">PERFORMANCE TUNING</A>
	<UL>

		<LI><A HREF="#code_cache">Code cache</A>
		<LI><A HREF="#object_files">Object files</A>
		<LI><A HREF="#preloading">Preloading</A>
		<LI><A HREF="#reload_file">Reload file</A>
	</UL>

	<LI><A HREF="#staging_vs_production">STAGING vs. PRODUCTION</A>
	<UL>

		<LI><A HREF="#out_mode">Out mode</A>
		<LI><A HREF="#error_mode">Error mode</A>
		<LI><A HREF="#debug_mode">Debug mode</A>
		<LI><A HREF="#reload_files">Reload files</A>
	</UL>

	<LI><A HREF="#configuring_virtual_sites">CONFIGURING VIRTUAL SITES</A>
	<UL>

		<LI><A HREF="#multiple_sites_one_component_ro">Multiple sites, one component root</A>
		<LI><A HREF="#multiple_sites_multiple_compone">Multiple sites, multiple component roots</A>
	</UL>

	<LI><A HREF="#authors">AUTHORS</A>
	<LI><A HREF="#see_also">SEE ALSO</A>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="name">NAME

</A></H1>
HTML::Mason::Admin - Mason Administrator's Guide


<P>

<P>
<HR>
<H1><A NAME="description">DESCRIPTION

</A></H1>
This guide is intended for the sys admin/web master in charge of
installing, configuring, or tuning a Mason system.


<P>

<P>
<HR>
<H1><A NAME="global_settings">GLOBAL SETTINGS

</A></H1>
The <CODE>Config.pm</CODE> file contains global settings for your system, such as the presence or
absence of certain optional modules.


<P>

<CODE>Makefile.PL</CODE> initially creates <CODE>Config.pm</CODE> based on your environment, placing it in the <CODE>lib/HTML/Mason</CODE> subdirectory of the distribution. After that, you can edit it by hand,
following the comments inside. In most cases, you will not need to edit it.


<P>

``make install'' copies <CODE>Config.pm</CODE> to your Perl library directory (e.g. <CODE>/usr/lib/perl5/site_perl/HTML/Mason</CODE>) along with the other module files. This allows Mason internally to grab
the configuration data with ``<CODE>use HTML::Mason::Config</CODE>''.


<P>

When upgrading from a previous version, ``make install'' will maintain the
previous <CODE>Config.pm</CODE> values.


<P>

<P>
<HR>
<H1><A NAME="site_configuration_methods">SITE CONFIGURATION METHODS

</A></H1>
There are three ways to configure a Mason site:


<P>

<UL>
<LI><STRONG></STRONG>
Minimal configuration, relying on default Mason behavior. Simplest and
least flexible.


<P>

<LI><STRONG></STRONG>
Configuration via httpd.conf directives. Medium complexity and flexibility.


<P>

<LI><STRONG></STRONG>
Configuration via a handler script (handler.pl). Most complex but most
flexible.


<P>

</UL>
The next three sections discuss these methods in detail. We recommend that
you start with the simplest method and work your way forward as the need
for flexibility arises.


<P>

<P>
<HR>
<H1><A NAME="minimal_configuration">MINIMAL CONFIGURATION

</A></H1>
A simple configuration looks like:


<P>

<PRE>    DocumentRoot /usr/local/www/htdocs
    PerlSetVar MasonCompRoot /usr/local/www/htdocs
    PerlSetVar MasonDataDir /usr/local/www/mason
    PerlModule HTML::Mason::ApacheHandler
</PRE>

<P>

<PRE>    &lt;FilesMatch &quot;*.html&quot;&gt;
        SetHandler perl-script
        PerlHandler HTML::Mason::ApacheHandler
    &lt;/FilesMatch&gt;
</PRE>

<P>

<CODE>MasonCompRoot</CODE> specifies the <EM>component root</EM>, the top of your component source tree. In simple configurations the
component root is the same as the server's <CODE>DocumentRoot</CODE>. (See <A HREF="#configuring_virtual_sites">CONFIGURING VIRTUAL SITES</A> to understand why the component root and <CODE>DocumentRoot</CODE> might differ.)


<P>

When Mason handles a request, the requested filename must be underneath
your component root -- that gives Mason a legitimate component to start
with. If the filename is not underneath the component root, Mason will
place a warning in the error logs and return 404.


<P>

<CODE>MasonDataDir</CODE> specifies the <EM>data directory</EM>, a writable directory that Mason uses for various features and
optimizations. Mason will create the directory on startup, if necessary,
and set its permissions according to the web server User/Group.


<P>

<P>
<HR>
<H1><A NAME="configuration_via_httpd_conf_dir">CONFIGURATION VIA httpd.conf DIRECTIVES

</A></H1>
Mason's configuration parameters are set via mod_perl's <CODE>PerlSetVar</CODE>
and <CODE>PerlAddVar</CODE> directives. The latter directive is only available in mod_perl version 1.24
and greater. Though these parameters are all strings, Mason treats them in
different ways. The different parameter types are:


<P>

<UL>
<LI><STRONG><A NAME="item_string">string

</A></STRONG>
The variable's value is simply taken literally and used. Quotes are
necessary if the string contains whitespace.


<P>

<LI><STRONG><A NAME="item_boolean">boolean

</A></STRONG>
The variable's value is used as a boolean, and is subject to Perl's rules
on truth/falseness. It is recommended that you use 0 (false) or 1 (true)
for these arguments.


<P>

<LI><STRONG><A NAME="item_code">code

</A></STRONG>
The string is treated as a piece of code and <CODE>eval</CODE>'ed. This is used for parameters that expect subroutine references. For
example, an anonymous subroutine might look like:


<P>

<PRE> PerlSetVar  MasonDieHandler  &quot;sub { die join ' -- ', @_ }&quot;
</PRE>

<P>

A named subroutine call would look like this:


<P>

<PRE> PerlSetVar  MasonDieHandler  &quot;\&amp;Carp::croak&quot;
</PRE>

<P>

<LI><STRONG><A NAME="item_list">list

</A></STRONG>
To set a list parameter, use <CODE>PerlAddVar</CODE> for the values, like this:


<P>

<PRE> PerlAddVar  MasonPreloads  /foo/bar/baz.comp
 PerlAddVar  MasonPreloads  /foo/bar/quux.comp
</PRE>

<P>

As noted above, <CODE>PerlAddVar</CODE> is only available in mod_perl 1.24 and up. This means that it is only
possible to assign a single value (using <CODE>PerlSetVar</CODE>) to list parameters if you are using a mod_perl older than 1.24.


<P>

</UL>
Almost all of Mason's configuration parameters correspond to
<CODE>new()</CODE> parameters for the <STRONG><A HREF="././Parser.html#">HTML::Mason::Parser</A></STRONG>,
<STRONG><A HREF="././Interp.html#">HTML::Mason::Interp</A></STRONG>, and <STRONG><A HREF="././ApacheHandler.html#">HTML::Mason::ApacheHandler</A></STRONG>
objects. Configuration parameters are named predictably by taking the
mixed-caps form of the <CODE>new()</CODE> parameter and prefixing
``Mason''. For example, comp_root becomes MasonCompRoot and data_dir
becomes MasonDataDir.


<P>

<P>
<HR>
<H2><A NAME="parser_parameters">Parser Parameters

</A></H2>
<UL>
<LI><STRONG><A NAME="item_MasonAllowGlobals">MasonAllowGlobals - list

</A></STRONG>
Corresponds to the <A HREF="././Parser.html#item_allow_globals">allow_globals</A> parameter.


<P>

<LI><STRONG><A NAME="item_MasonDefaultEscapeFlags">MasonDefaultEscapeFlags - string

</A></STRONG>
Corresponds to the <A HREF="././Parser.html#item_default_escape_flags">default_escape_flags</A> parameter.


<P>

<LI><STRONG><A NAME="item_MasonIgnoreWarningsExpr">MasonIgnoreWarningsExpr - string

</A></STRONG>
Corresponds to the <A HREF="././Parser.html#item_ignore_warnings_expr">ignore_warnings_expr</A> parameter.


<P>

<LI><STRONG><A NAME="item_MasonInPackage">MasonInPackage - string

</A></STRONG>
Corresponds to the <A HREF="././Parser.html#item_in_package">in_package</A> parameter.


<P>

<LI><STRONG><A NAME="item_MasonPostamble">MasonPostamble - string

</A></STRONG>
Corresponds to the <A HREF="././Parser.html#item_postamble">postamble</A> parameter.


<P>

<LI><STRONG><A NAME="item_MasonPreamble">MasonPreamble - string

</A></STRONG>
Corresponds to the <A HREF="././Parser.html#item_preamble">preamble</A> parameter.


<P>

<LI><STRONG><A NAME="item_MasonTaintCheck">MasonTaintCheck - boolean

</A></STRONG>
Corresponds to the <A HREF="././Parser.html#item_taint_check">taint_check</A> parameter.


<P>

<LI><STRONG><A NAME="item_MasonUseStrict">MasonUseStrict - boolean

</A></STRONG>
Corresponds to the <A HREF="././Parser.html#item_use_strict">use_strict</A> parameter.


<P>

<LI><STRONG><A NAME="item_MasonPreprocess">MasonPreprocess - code

</A></STRONG>
Corresponds to the <A HREF="././Parser.html#item_preprocess">preprocess</A> parameter.


<P>

<LI><STRONG><A NAME="item_MasonPostprocess">MasonPostprocess - code

</A></STRONG>
Corresponds to the <A HREF="././Parser.html#item_postprocess">postprocess</A> parameter.


<P>

</UL>
<P>
<HR>
<H2><A NAME="interp_parameters">Interp Parameters

</A></H2>
<UL>
<LI><STRONG><A NAME="item_MasonCompRoot">MasonCompRoot - string or list

</A></STRONG>
Correponds to the <A HREF="././Interp.html#item_comp_root">comp_root</A> parameter. This parameter can either be a single value, such as
'/foo/comp/root', or a list of keys and values such as:


<P>

<PRE> PerlAddVar  MasonCompRoot  &quot;root1 =&gt; /foo/comp/root1&quot;
 PerlAddVar  MasonCompRoot  &quot;shared =&gt; /my/shared/comps&quot;
</PRE>

<P>

See the <A HREF="#multiple_component_roots">Multiple component roots</A> section for more details on multiple component roots.


<P>

<LI><STRONG><A NAME="item_MasonDataDir">MasonDataDir - string (required)

</A></STRONG>
Corresponds to the <A HREF="././Interp.html#item_data_dir">data_dir</A> parameter.


<P>

<LI><STRONG><A NAME="item_MasonAllowRecursiveAutohandlers">MasonAllowRecursiveAutohandlers - boolean

</A></STRONG>
Corresponds to the <A HREF="././Interp.html#item_allow_recursive_autohandlers">allow_recursive_autohandlers</A> parameter.


<P>

<LI><STRONG><A NAME="item_MasonAutohandlerName">MasonAutohandlerName - string

</A></STRONG>
Corresponds to the <A HREF="././Interp.html#item_autohandler_name">autohandler_name</A> parameter.


<P>

<LI><STRONG><A NAME="item_MasonCodeCacheMaxSize">MasonCodeCacheMaxSize - string

</A></STRONG>
Corresponds to the <A HREF="././Interp.html#item_code_cache_max_size">code_cache_max_size</A> parameter.


<P>

<LI><STRONG><A NAME="item_MasonCurrentTime">MasonCurrentTime - string

</A></STRONG>
Corresponds to the <A HREF="././Interp.html#item_current_time">current_time</A> parameter.


<P>

<LI><STRONG><A NAME="item_MasonDataCacheDir">MasonDataCacheDir - string

</A></STRONG>
Corresponds to the <A HREF="././Interp.html#item_data_cache_dir">data_cache_dir</A> parameter.


<P>

<LI><STRONG><A NAME="item_MasonDieHandler">MasonDieHandler - code or 0

</A></STRONG>
Corresponds to the <A HREF="././Interp.html#item_die_handler">die_handler</A> parameter.


<P>

<LI><STRONG><A NAME="item_MasonMaxRecurse">MasonMaxRecurse - string

</A></STRONG>
Corresponds to the <A HREF="././Interp.html#item_max_recurse">max_recurse</A> parameter.


<P>

<LI><STRONG><A NAME="item_MasonOutMethod">MasonOutMethod - code

</A></STRONG>
Corresponds to the <A HREF="././Interp.html#item_out_method">out_method</A> parameter.


<P>

<LI><STRONG><A NAME="item_MasonOutMode">MasonOutMode - string

</A></STRONG>
Corresponds to the <A HREF="././Interp.html#item_out_mode">out_mode</A> parameter.


<P>

<LI><STRONG><A NAME="item_MasonPreloads">MasonPreloads - list

</A></STRONG>
Corresponds to the <A HREF="././Interp.html#item_preloads">preloads</A> parameter.


<P>

<LI><STRONG><A NAME="item_MasonStaticFileRoot">MasonStaticFileRoot - string

</A></STRONG>
Corresponds to the <A HREF="././Interp.html#item_static_file_root">static_file_root</A> parameter.


<P>

<LI><STRONG><A NAME="item_MasonSystemLogEvents">MasonSystemLogEvents - string

</A></STRONG>
Corresponds to the <A HREF="././Interp.html#item_system_log_events">system_log_events</A> parameter.


<P>

<LI><STRONG><A NAME="item_MasonSystemLogFile">MasonSystemLogFile - string

</A></STRONG>
Corresponds to the <A HREF="././Interp.html#item_system_log_file">system_log_file</A> parameter.


<P>

<LI><STRONG><A NAME="item_MasonSystemLogSeparator">MasonSystemLogSeparator - string

</A></STRONG>
Corresponds to the <A HREF="././Interp.html#item_system_log_separator">system_log_separator</A> parameter.


<P>

<LI><STRONG><A NAME="item_MasonUseAutohandlers">MasonUseAutohandlers - boolean

</A></STRONG>
Corresponds to the <A HREF="././Interp.html#item_use_autohandlers">use_autohandlers</A> parameter.


<P>

<LI><STRONG><A NAME="item_MasonUseDataCache">MasonUseDataCache - boolean

</A></STRONG>
Corresponds to the <A HREF="././Interp.html#item_use_data_cache">use_data_cache</A> parameter.


<P>

<LI><STRONG><A NAME="item_MasonUseDhandlers">MasonUseDhandlers - boolean

</A></STRONG>
Corresponds to the <A HREF="././Interp.html#item_use_dhandlers">use_dhandlers</A> parameter.


<P>

<LI><STRONG><A NAME="item_MasonUseObjectFiles">MasonUseObjectFiles - boolean

</A></STRONG>
Corresponds to the <A HREF="././Interp.html#item_use_object_files">use_object_files</A> parameter.


<P>

<LI><STRONG><A NAME="item_MasonUseReloadFile">MasonUseReloadFile - boolean

</A></STRONG>
Corresponds to the <A HREF="././Interp.html#item_use_reload_file">use_reload_file</A> parameter.


<P>

</UL>
<P>
<HR>
<H2><A NAME="apachehandler_parameters">ApacheHandler Parameters

</A></H2>
<UL>
<LI><STRONG><A NAME="item_MasonApacheStatusTitle">MasonApacheStatusTitle - string

</A></STRONG>
Correponds to the <A HREF="././ApacheHandler.html#item_apache_status_title">apache_status_title</A> parameter.


<P>

<LI><STRONG><A NAME="item_MasonAutoSendHeaders">MasonAutoSendHeaders - boolean

</A></STRONG>
Correponds to the <A HREF="././ApacheHandler.html#item_auto_send_headers">auto_send_headers</A> parameter.


<P>

<LI><STRONG><A NAME="item_MasonDebugHandlerProc">MasonDebugHandlerProc - string

</A></STRONG>
Correponds to the <A HREF="././ApacheHandler.html#item_debug_handler_proc">debug_handler_proc</A> parameter.


<P>

<LI><STRONG><A NAME="item_MasonDebugHandlerScript">MasonDebugHandlerScript - string

</A></STRONG>
Correponds to the <A HREF="././Admin.html#item_debug_handler_script">debug_handler_script</A> parameter.


<P>

<LI><STRONG><A NAME="item_MasonDebugMode">MasonDebugMode - string

</A></STRONG>
Correponds to the <A HREF="././Admin.html#item_debug_mode">debug_mode</A> parameter.


<P>

<LI><STRONG><A NAME="item_MasonDebugPerlBinary">MasonDebugPerlBinary - string

</A></STRONG>
Correponds to the <A HREF="././Admin.html#item_debug_perl_binary">debug_perl_binary</A> parameter.


<P>

<LI><STRONG><A NAME="item_MasonErrorMode">MasonErrorMode - string

</A></STRONG>
Correponds to the <A HREF="././ApacheHandler.html#item_error_mode">error_mode</A> parameter.


<P>

<LI><STRONG><A NAME="item_MasonTopLevelPredicate">MasonTopLevelPredicate - code

</A></STRONG>
Correponds to the <A HREF="././ApacheHandler.html#item_top_level_predicate">top_level_predicate</A> parameter.


<P>

</UL>
<P>
<HR>
<H2><A NAME="special_parameters">Special Parameters

</A></H2>
These are the only parameters that do <EM>not</EM> correspond to <CODE>new()</CODE> parameters.


<P>

<UL>
<LI><STRONG><A NAME="item_MasonArgsMethod">MasonArgsMethod - string

</A></STRONG>
Valid values for this parameter are <CODE>CGI</CODE> or <CODE>mod_perl</CODE>. This determines whether to use the <CODE>CGI</CODE> or <CODE>Apache::Request</CODE> module for argument handling. Please see <A HREF="././ApacheHandler.html#parameters_to_the_use_declarat">PARAMETERS TO THE use() DECLARATION</A>
for more details.


<P>

This can only be set once, regardless of how you set MasonMultipleConfig.


<P>

Defaults to <CODE>CGI</CODE>.


<P>

<LI><STRONG><A NAME="item_MasonMultipleConfig">MasonMultipleConfig - boolean

</A></STRONG>
If this parameter is true, Mason assumes that you may have multiple sets of
configuration directives defined, perhaps for multiple locations or virtual
hosts. This means that Mason will create a new set of parser/interp/handler
objects for every request. If this parameter is false, Mason simply creates
a single set at server startup to maximize shared memory. Defaults to
false.


<P>

If you set this option, the Apache child processes will need the proper
permissions to create the data directories.


<P>

</UL>
<P>
<HR>
<H2><A NAME="memory_usage">Memory Usage

</A></H2>
To maximize shared memory, you should put your Mason configuration
directives in the configuration file <STRONG>before</STRONG> you load the
<CODE>HTML::Mason::ApacheHandler</CODE> module via a <CODE>PerlModule</CODE> directive.


<P>

Because certain features were not available in mod_perl before 1.21_01,
Mason will be less memory efficient when using those older versions.


<P>

<P>
<HR>
<H1><A NAME="configuring_via_a_handler_script">CONFIGURING VIA A HANDLER SCRIPT

</A></H1>
For maximum flexibility, you may choose to write a custom script to create
your Mason objects and handle requests. In our documentation and examples
we call this script <CODE>handler.pl</CODE>, though you may name it whatever you like.


<P>

The <CODE>handler.pl</CODE> file is responsible for creating the three Mason objects and supplying the
many parameters that control how your components are parsed and executed.
It also provides the opportunity to execute arbitrary code at three
important junctures: the server initialization, the beginning of a request,
and the end of a request. A wide set of behaviors can be implemented with a
mere few lines of well-placed Perl in your <CODE>handler.pl</CODE>. In this section we present the basics of setting up <CODE>handler.pl</CODE> as well as some ideas for more advanced applications.


<P>

<P>
<HR>
<H2><A NAME="creating_the_mason_objects">Creating the Mason objects

</A></H2>
<CODE>handler.pl</CODE> creates three Mason objects: the Parser, Interpreter, and ApacheHandler.
The Parser compiles components into Perl subroutines; the Interpreter
executes those compiled components; and the Apache handler routes mod_perl
requests to Mason. These objects are created once in the parent httpd and
then copied to each child process.


<P>

These objects have a fair number of possible parameters. Only two of them
are required, <EM>comp_root</EM> and <EM>data_dir</EM>; these are discussed in the next two subsections. The various parameters
are documented in the individual reference manuals for each object:
<STRONG><A HREF="././Parser.html#">HTML::Mason::Parser</A></STRONG>, <STRONG><A HREF="././Interp.html#">HTML::Mason::Interp</A></STRONG>, and
<STRONG><A HREF="././ApacheHandler.html#">HTML::Mason::ApacheHandler</A></STRONG>.


<P>

The advantage of embedding these parameters in objects is that advanced
configurations can create more than one set of objects, choosing which set
to use at request time. For example, suppose you have a staging site and a
production site running on the same web server, distinguishing between them
with a configuration variable called <CODE>version</CODE>:


<P>

<PRE>    # Create Mason objects for staging site
    my $parser1 = new HTML::Mason::Parser;
    my $interp1 = new HTML::Mason::Interp (parser=&gt;$parser1, ...);
    my $ah1 = new HTML::Mason::ApacheHandler (interp=&gt;$interp1);
</PRE>

<P>

<PRE>    # Create Mason objects for production site
    my $parser2 = new HTML::Mason::Parser;
    my $interp2 = new HTML::Mason::Interp (parser=&gt;$parser2, ...);
    my $ah2 = new HTML::Mason::ApacheHandler (interp=&gt;$interp2);
</PRE>

<P>

<PRE>    sub handler {
        ...
</PRE>

<P>

<PRE>        # Choose the right ApacheHandler
        if ($r-&gt;dir_config('version') eq ' staging') {
            $ah1-&gt;handle_request($r);
        } else {
            $ah2-&gt;handle_request($r);
        }
    }
</PRE>

<P>

<P>
<HR>
<H2><A NAME="multiple_component_roots">Multiple component roots

</A></H2>
You may specify multiple component roots to be searched in the spirit of
Perl's <CODE>@INC</CODE>. To do so you must specify a list of lists:


<P>

<PRE>    comp_root =&gt; [[key1, root1], [key2, root2], ...]
</PRE>

<P>

Each pair consists of a key and root. The key is a string that identifies
the root mnemonically to a component developer. Keys are case-insensitive
and must be distinct.


<P>

For example:


<P>

<PRE>    comp_root =&gt; [[private=&gt;'/usr/home/joe/comps'], [main=&gt;'/usr/local/www/htdocs']]
</PRE>

<P>

This specifies two component roots, a main component tree and a private
tree which overrides certain components. The order is respected ala <CODE>@INC</CODE>, so <EM>private</EM> is searched first and <EM>main</EM> second. (I chose the <CODE>=&gt;</CODE> notation here because it looks cleaner, but note that this is a list of
lists, not a hash.)


<P>

The key has several purposes. Object and data cache filenames use the
(uppercased) key to make sure different components sharing the same path
have different cache and object files. For example, if a component /foo/bar
is found in 'private', then the object file will be


<P>

<PRE>    &lt;data_dir&gt;/obj/PRIVATE/foo/bar
</PRE>

<P>

and the cache file


<P>

<PRE>    &lt;data_dir&gt;/cache/PRIVATE+2ffoo+2fbar
</PRE>

<P>

The key is also included whenever Mason prints the component title, as in
an error message:


<P>

<PRE>    error while executing /foo/bar [private]:
    ...
</PRE>

<P>

This lets you know which version of the component was running.


<P>

<P>
<HR>
<H2><A NAME="external_modules">External modules

</A></H2>
Components will often need access to external Perl modules. Any such
modules that export symbols should be listed in <CODE>handler.pl</CODE>, rather than the standard practice of using a PerlModule configuration
directive. This is because components are executed inside the
<STRONG>HTML::Mason::Commands</STRONG> package, and can only access symbols exported to that package. Here's
sample module list:


<P>

<PRE>    { package HTML::Mason::Commands;
      use CGI ':standard';
      use LWP::UserAgent;
      ... }
</PRE>

<P>

In any case, for optimal memory utilization, make sure all Perl modules are
used in the parent process, and <EM>not</EM> in components. Otherwise, each child allocates its own copy and you lose
the benefit of shared memory between parent processes and their children.
See Vivek Khera's mod_perl tuning FAQ (perl.apache.org/tuning) for details.


<P>

<P>
<HR>
<H2><A NAME="file_ownership">File ownership

</A></H2>
Unix web servers that run on privileged ports like 80 start with a root
parent process, then spawn children running as the 'User' and 'Group'
specified in httpd.conf. This difference leads to permission errors when
child processes try to write files or directories created by the parent
process.


<P>

To work around this conflict, Mason remembers all directories and files
created at startup, returning them in response to
<CODE>interp-&gt;files_written</CODE>. This list can be fed to a <CODE>chown()</CODE> at the end of the startup
code in <CODE>handler.pl</CODE>:


<P>

<PRE>    chown (Apache-&gt;server-&gt;uid, Apache-&gt;server-&gt;gid, $interp-&gt;files_written);
</PRE>

<P>

<P>
<HR>
<H2><A NAME="persistent_user_sessions">Persistent user sessions

</A></H2>
With just a few lines in <CODE>handler.pl</CODE> you can make a global hash (e.g. <EM>%session</EM>) available to all components containing persistent user session data. If
you set a value in the hash, you will see the change in future visits by
the same user. The key piece is Jeffrey Baker's
<STRONG>Apache::Session</STRONG> module, available from CPAN.


<P>

The file <CODE>eg/session_handler.pl</CODE> in the distribution contains the lines to activate cookie-based sessions
using Apache::Session and CGI::Cookie. You can use <CODE>eg/session_handler.pl</CODE> as your new <CODE>handler.pl</CODE>
base, or just copy out the appropriate pieces to your existing <CODE>handler.pl</CODE>.


<P>

The session code is customizable; you can change the user ID location (e.g.
URL instead of cookie), the user data storage mechanism (e.g. DBI
database), and the name of the global hash.


<P>

<P>
<HR>
<H2><A NAME="using_global_variables">Using global variables

</A></H2>
Global variables generally make programs harder to read, maintain, and
debug, and this is no less true for Mason. Due to the persistent mod_perl
environment, globals require extra initialization and cleanup care. And the
highly modular nature of Mason pages does not mix well with globals: it is
no fun trying to track down which of twenty components is stepping on your
variable. With the ability to pass parameters and declare lexical (<CODE>my</CODE>) variables in components, there is very little need for globals at all.


<P>

That said, there are times when it is very useful to make a value available
to all Mason components: a DBI database handler, a hash of user session
information, the server root for forming absolute URLs. Usually you
initialize the global in your <CODE>handler.pl</CODE>, either outside the <CODE>handler()</CODE> subroutine (if you only need to
set it once) or inside (if you need to set it every request).


<P>

Mason by default parses components in <CODE>strict</CODE> mode, so you can't simply start referring to a new global or you'll get a
fatal warning. The solution is to invoke <CODE>use vars</CODE> inside the package that components execute in, by default <STRONG>HTML::Mason::Commands</STRONG>:


<P>

<PRE>    { package HTML::Mason::Commands;
      use vars qw($dbh %session);
    }
</PRE>

<P>

Alternatively you can use the <A HREF="./Parser.html#item_allow_globals">allow_globals</A> parameter or method:


<P>

<PRE>    my $parser = new HTML::Mason::Parser (..., allow_globals =&gt; [qw($dbh %session)]);
    $parser-&gt;allow_globals(qw($foo @bar))
</PRE>

<P>

The only advantage to <A HREF="././Parser.html#item_allow_globals">allow_globals</A> is that it will do the right thing if you've chosen a different package for
components to run in (via the <A HREF="./Parser.html#item_in_package">in_package</A> Parser parameter.)


<P>

Similarly, to initialize the variable in <CODE>handler.pl</CODE>, you need to set it in the component package:


<P>

<PRE>   $HTML::Mason::Commands::dbh = DBI-&gt;connect(...);
</PRE>

<P>

Alternatively you can use the <A HREF="./Interp.html#item_set_global">set_global</A> Interp method:


<P>

<PRE>    $interp-&gt;set_global(dbh =&gt; DBI-&gt;connect(...));
</PRE>

<P>

Again, <A HREF="././Interp.html#item_set_global">set_global</A> will do the right thing if you've chosen a different package for
components.


<P>

Now when referring to these globals inside components, you can use the
plain variable name:


<P>

<PRE>    $dbh-&gt;prepare...
</PRE>

<P>

<P>
<HR>
<H2><A NAME="declining_image_requests">Declining image requests

</A></H2>
Mason should be prevented from serving images, tarballs, and other binary
files as regular components. Such a file may inadvertently contain a Mason
character sequence such as ``&lt;%'', causing an error.


<P>

There are several ways to restrict which file types are handled by Mason.
One way is with a line at the top of <CODE>handler(),</CODE> e.g.:


<P>

<PRE>    return -1 if $r-&gt;content_type &amp;&amp; $r-&gt;content_type !~ m|^text/|i;
</PRE>

<P>

This line allows text/html and text/plain to pass through but not much
else. It is included (commented out) in the default <CODE>handler.pl</CODE>.


<P>

Another way is specifying a filename pattern in the Apache configuration,
e.g.:


<P>

<PRE>    &lt;FilesMatch &quot;(\.html|\.txt|^[^\.]+)$&gt;
    SetHandler perl-script
    PerlHandler HTML::Mason
    &lt;/FilesMatch&gt;
</PRE>

<P>

This directs Mason to handle only files with .html, .txt, or no extension.


<P>

<P>
<HR>
<H2><A NAME="securing_top_level_components">Securing top-level components

</A></H2>
Users may exploit a server-side scripting environment by invoking scripts
with malicious or unintended arguments. Mason administrators need to be
particularly wary of this because of the tendency to break out
``subroutines'' into individually accessible file components.


<P>

For example, a Mason developer might create a helpful shared component for
performing sql queries:


<P>

<PRE>    $m-&gt;comp('sql_select', table=&gt;'employee', where=&gt;'id=315');
</PRE>

<P>

This is a perfectly reasonable component to create and call internally, but
clearly presents a security risk if accessible via URL:


<P>

<PRE>    http://www.foo.com/sql_select?table=credit_cards&amp;where=*
</PRE>

<P>

Of course a web user would have to obtain the name of this component
through guesswork or other means, but obscurity alone does not properly
secure a system. Rather, you should choose a site-wide policy for
distinguishing top-level components from private components, and make sure
your developers stick to this policy. You can then prevent private
components from being served.


<P>

One solution is to place all private components inside a directory, say
/private, that lies under the component root but outside the document root.


<P>

Another solution is to decide on a naming convention, for example, that all
private components begin with ``_'', or that all top-level components must
end in ``.html''. Then turn all private requests away with a 404 NOT_FOUND
(rather than, say, a 403 FORBIDDEN which would provide more information
than necessary). Use either an Apache directive


<P>

<PRE>    PerlModule Apache::Constants
    &lt;FilesMatch &quot;^_&quot;&gt;
    SetHandler perl-script
    PerlInitHandler Apache::Constants::NOT_FOUND
    &lt;/FilesMatch&gt;
</PRE>

<P>

or a <CODE>handler.pl</CODE> directive:


<P>

<PRE>    return 404 if $r-&gt;filename =~ m{^_[^/]+$};
</PRE>

<P>

Even after you've safely protected internal components, top-level
components that process arguments (such as form handlers) still present a
risk. Users can invoke such a component with arbitrary argument values via
a handcrafted query string. Always check incoming arguments for validity
and never place argument values directly into SQL, shell commands, etc.
Unfortunately, Mason does not yet work with with Perl's taint checking
which would help ensure these principles.


<P>

<P>
<HR>
<H2><A NAME="allowing_directory_requests">Allowing directory requests

</A></H2>
By default Mason will decline requests for directories, leaving Apache to
serve up a directory index or a FORBIDDEN as appropriate. Unfortunately
this rule applies even if there is a dhandler in the directory:
/foo/bar/dhandler does not get a chance to handle a request for /foo/bar.


<P>

If you would like Mason to handle directory requests, do the following:


<P>

1. Set the <A HREF="./ApacheHandler.html#item_decline_dirs">decline_dirs</A> ApacheHandler parameter to 0.


<P>

2. If your <CODE>handler.pl</CODE> contains the standard ``return -1'' line to decline non-text requests (as
given in the previous section), add a clause allowing directory types:


<P>

<PRE>    return -1 if $r-&gt;content_type &amp;&amp; $r-&gt;content_type !~ m|^text/|i
                 &amp;&amp; $r-&gt;content_type !~ m|directory$|i;
</PRE>

<P>

The dhandler that catches a directory request is responsible for setting a
reasonable content type.


<P>

<P>
<HR>
<H1><A NAME="standard_features">STANDARD FEATURES

</A></H1>
This section explains how standard Mason features work and how to
administer them.


<P>

<P>
<HR>
<H2><A NAME="data_caching">Data caching

</A></H2>
<DL>
<DT><STRONG><A NAME="item_Setup">Setup

</A></STRONG><DD>
Cache files are implemented using <STRONG>MLDBM</STRONG>, an interface for storing persistent multi-level data structures. <STRONG>MLDBM</STRONG>, in turn, uses one of several DBM packages (<STRONG>DB_File</STRONG>, <STRONG>GDBM</STRONG>) and one of several serialization mechanisms (<STRONG>Data::Dumper</STRONG>, <STRONG>FreezeThaw</STRONG> or
<STRONG>Storable</STRONG>). Mason's <CODE>Config.pm</CODE> controls which packages are used.


<P>

The most important task is selecting a good DBM package. Most standard DBM
packages (<STRONG>SDBM</STRONG>, <STRONG>ODBM</STRONG>, <STRONG>NDBM</STRONG>) are unsuitable for data caching due to significant limitations on the
size of keys and values. Perl only comes with <STRONG>SDBM</STRONG>, so you'll need to obtain a good-quality package if you haven't already.
At this time the best options are Berkeley DB (<STRONG>DB_File</STRONG>) version 2.x, available at www.sleepycat.com, and GNU's gdbm (<STRONG>GDBM</STRONG>), available at GNU mirror sites everywhere. Stay away from Berkeley DB
version 1.x on Linux which has a serious memory leak (and is unfortunately
pre-installed on many distributions).


<P>

As far as the serialization methods, all of them should work fine. <STRONG>Data::Dumper</STRONG> is probably simplest: it comes with the latest versions of Perl, is
required by Mason anyway, and produces readable output (possibly useful for
debugging cache files). On the other hand
<STRONG>Storable</STRONG> is significantly faster than the other options according to the MLDBM
documentation.


<P>

Data caching will not work on systems lacking <CODE>flock(),</CODE> such as
Windows 95 and 98.


<P>

<DT><STRONG><A NAME="item_Administration">Administration

</A></STRONG><DD>
Once set up, data caching requires little administration. When a component
calls <CODE>$m-&gt;cache</CODE> or <CODE>$m-&gt;cache_self</CODE> for the first time, Mason automatically creates a new cache file under <CODE>data_dir/cache</CODE>. The name of the file is determined by encoding the path as follows:


<P>

<PRE>    s/([^\w\.\-\~])/sprintf('+%02x', ord $1)/eg;
</PRE>

<P>

like URL encoding with a '+' escape character. For example, the cache file
for component <CODE>/foo/bar</CODE> is <CODE>data_dir/cache/foo+2fbar</CODE>.


<P>

Currently Mason never deletes cache files, not even when the associated
component file is modified. (This may change in the near future.) Thus
cache files hang around and grow indefinitely. You may want to use a cron
job or similar mechanism to delete cache files that get too large or too
old. For example:


<P>

<PRE>    # Shoot cache files more than 30 days old
    foreach (&lt;data_dir/cache&gt;) {    # path to cache directory
        unlink $_ if (-M &gt;= 30);
    }
</PRE>

<P>

In general you can feel free to delete cache files periodically and without
warning, because the data cache mechanism is explicitly not guaranteed --
developers are warned that cached data may disappear anytime and components
must still function.


<P>

If some reason you want to disable data caching, specify
<A HREF="././Interp.html#item_use_data_cache">use_data_cache</A>=&gt;0 to the Interp object. This will cause all <CODE>$m-&gt;cache</CODE>
calls to return undef without doing anything.


<P>

</DL>
<P>
<HR>
<H2><A NAME="debugging">Debugging

</A></H2>
A debug file is a Perl script that creates a fake Apache request object (<CODE>$r</CODE>) and calls the same PerlHandler that Apache called. Debug files are
created under <CODE>data_dir/debug/&lt;username&gt;</CODE> for authenticated users, and in <CODE>data_dir/debug/anon</CODE> for anonymous users.


<P>

Debug files can only be used with the <CODE>handler.pl</CODE> configuration method. 


<P>

Several ApacheHandler parameters are required to activate and configure
debug files:


<P>

<DL>
<DT><STRONG><A NAME="item_debug_mode">debug_mode

</A></STRONG><DD>
The debug_mode parameter indicates which requests should produce a debug
file: ``all'', ``none'', or ``error'' (only if a error occurs).


<P>

<DT><STRONG><A NAME="item_debug_perl_binary">debug_perl_binary

</A></STRONG><DD>
The full path to your Perl binary -- e.g. <CODE>/usr/bin/perl</CODE>. This is used in the Unix ``shebang'' line at the top of each debug file.


<P>

<DT><STRONG><A NAME="item_debug_handler_script">debug_handler_script

</A></STRONG><DD>
The full path to your <CODE>handler.pl</CODE> script. Debug files invoke
<CODE>handler.pl</CODE> just as Apache does as startup, to load needed modules and create Mason
objects.


<P>

<DT><STRONG><A NAME="item_debug_handler_proc">debug_handler_proc

</A></STRONG><DD>
The name of the request handler defined in <CODE>handler.pl</CODE>. This routine is called with the saved Apache request object.


<P>

</DL>
Here's a sample <CODE>ApacheHandler</CODE> constructor with all debug options:


<P>

<PRE>    my $ah = new HTML::Mason::ApacheHandler (interp=&gt;$interp,
               debug_mode=&gt;'all',
               debug_perl_binary=&gt;'/usr/local/bin/perl',
               debug_handler_script=&gt;'/usr/local/mason/eg/handler.pl',
               debug_handler_proc=&gt;'HTML::Mason::handler');
</PRE>

<P>

When replaying a request through a debug file, the global variable
<CODE>$HTML::Mason::IN_DEBUG_FILE</CODE> will be set to 1. This is useful if you want to omit certain flags (like
preloading) in <CODE>handler.pl</CODE> when running under debug. For example:


<P>

<PRE>    my %extra_flags = ($HTML::Mason::IN_DEBUG_FILE) ? () : (preloads=&gt;[...]);
    my $interp = new HTML::Mason::Interp (..., %extra_flags);
</PRE>

<P>

<P>
<HR>
<H2><A NAME="previewer">Previewer

</A></H2>
The previewer is a web based utility that allows site developers to:


<P>

<OL>
<LI><STRONG><A NAME="item_">

</A></STRONG>
View a site under a variety of simulated client conditions: browser,
operating system, date, time of day, referer, etc.


<P>

<LI><STRONG><A NAME="item_">

</A></STRONG>
View a debug trace of a page, showing the component call tree and
indicating which parts of the page are generated by which components.


<P>

</OL>
The web-based previewer interface (a single component, actually) allows the
developer to select a variety of options such as time, browser, and display
mode. The set of these options together is called a previewer
configuration. Configurations can be saved under one of several preview
ports. For more information on how the previewer is used, see <STRONG><A HREF="././Devel.html#">HTML::Mason::Devel</A></STRONG>.


<P>

Follow these steps to activate the Previewer:


<P>

<OL>
<LI><STRONG><A NAME="item_">

</A></STRONG>
Choose a set of preview ports, for example, 3001 to 3005.


<P>

<LI><STRONG><A NAME="item_">

</A></STRONG>
In httpd.conf, put a Listen in for each port. E.g.


<P>

<PRE>  Listen your.site.ip.address:3001
  ...
  Listen your.site.ip.address:3005
</PRE>

<P>

You'll also probably want to restrict access to these ports in your
access.conf. If you have multiple site developers, it is helpful to use
username/password access control, since the previewer will use the username
to keep configurations separate.


<P>

<LI><STRONG><A NAME="item_">

</A></STRONG>
In your <CODE>handler.pl</CODE>, add the line


<P>

<PRE>    use HTML::Mason::Preview;
</PRE>

<P>

somewhere underneath ``use HTML::Mason''. Then add code to your handler
routine to intercept Previewer requests on the ports defined above. Your
handler should end up looking like this:


<P>

<PRE>    sub handler {
        my ($r) = @_;
</PRE>

<P>

<PRE>        # Compute port number from Host header
        my $host = $r-&gt;header_in('Host');
        my ($port) = ($host =~ /:([0-9]+)$/);
        $port = 80 if (!defined($port));
</PRE>

<P>

<PRE>        # Handle previewer request on special ports
        if ($port &gt;= 3001 &amp;&amp; $port &lt;= 3005) {
            my $parser = new HTML::Mason::Parser(...);
            my $interp = new HTML::Mason::Interp(...);
            my $ah = new HTML::Mason::ApacheHandler (...);
            return HTML::Mason::Preview::handle_preview_request($r,$ah);
        } else {
            $ah-&gt;handle_request($r);    # else, normal request handler
        }
    }
</PRE>

<P>

The three ``new'' lines inside the if block should look exactly the same as
the lines at the top of <CODE>handler.pl</CODE>. Note that these separate Mason objects are created for a single request
and discarded. The reason is that the previewer may alter the objects'
settings, so it is safer to create new ones every time.


<P>

<LI><STRONG><A NAME="item_">

</A></STRONG>
Copy the Previewer component (``samples/preview'') to your component root
(you may want to place it at the top level so that <A
HREF="http://www.yoursite.com/preview">http://www.yoursite.com/preview</A>
calls up the previewer interface). Edit the ``CONFIGURATION'' block at the
top to conform to your own Mason setup.


<P>

</OL>
To test whether the previewer is working: restart your server, go to the
previewer interface, and click ``View''. You should see your site's home
page.


<P>

<P>
<HR>
<H2><A NAME="system_logs">System logs

</A></H2>
Mason will log various events to a system log file if you so desire. This
can be useful for performance monitoring and debugging.


<P>

The format of the system log was designed to be easy to parse by programs,
although it is not unduly hard to read for humans. Every event is logged on
one line. Each line consists of multiple fields delimited by a common
separator, by default ctrl-A. The first three fields are always the same:
time, the name of the event, and the current pid ($$). These are followed
by one or more fields specific to the event.


<P>

The events are:


<P>

<PRE> EVENT NAME     DESCRIPTION                     EXTRA FIELDS
</PRE>

<P>

<PRE> REQ_START      start of HTTP request           request number, URL + query string
 REQ_END        end of HTTP request             request number, error flag (1 if
                                                error occurred, 0 otherwise)
 CACHE_READ     attempt to read from            component path, cache key, success
                data cache (C&lt;$m-E&lt;gt&gt;cache&gt;)   flag (1 if item found, 0 otherwise)
 CACHE_STORE    store to data cache             component path, cache key
 COMP_LOAD      component loaded into memory    component path
                for first time  
</PRE>

<P>

The request number is an incremental value that uniquely identifies each
request for a given child process. Use it to match up REQ_START/REQ_END
pairs.


<P>

To turn on logging, specify a string value to <A HREF="././Interp.html#item_system_log_events">system_log_events</A>
containing one or more event names separated by '|'. In additional to
individual event names, the following names can be used to specify multiple
events:


<P>

<PRE> REQUEST = REQ_START | REQ_END
 CACHE = CACHE_READ | CACHE_STORE
 ALL = All events
</PRE>

<P>

For example, to log REQ_START, REQ_END, and COMP_LOAD events, you could use
system_log_events =&gt; ``REQUEST|COMP_LOAD'' Note that this is a string,
not a set of constants or'd together.


<P>

<STRONG>Configuration Options</STRONG>




<P>

By default, the system log will be placed in data_dir/etc/system.log. You
can change this with <A HREF="././Interp.html#item_system_log_file">system_log_file</A>.


<P>

The default line separator is ctrl-A. The advantage of this separator is
that it is very unlikely to appear in any of the fields, making it easy to
<CODE>split()</CODE> the line. The disadvantage is that it will not always
display, e.g. from a Unix shell, making the log harder to read casually.
You can change the separator to any sequence of characters with <A HREF="././Interp.html#item_system_log_separator">system_log_separator</A>.


<P>

The time on each log line will be of the form ``seconds.microseconds'' if
you are using Time::HiRes, and simply ``seconds'' otherwise. See
<CODE>Config.pm</CODE> section.


<P>

<STRONG>Sample Log Parser</STRONG>




<P>

Here is a code skeleton for parsing the various events in a log. You can
also find this in <CODE>eg/parselog.pl</CODE> in the Mason distribution.


<P>

<PRE>   open(LOG,&quot;mason.log&quot;);
   while (&lt;LOG&gt;) {
       chomp;
       my (@fields) = split(&quot;\cA&quot;);
       my ($time,$event,$pid) = splice(@fields,0,3);
       if ($event eq 'REQ_START') {
           my ($reqnum,$url) = @fields;
           ...
       } elsif ($event eq 'REQ_END') {
           my ($reqnum,$errflag) = @fields;
           ...
       } elsif ($event eq 'CACHE_READ') {  
           my ($comp,$key,$hitflag) = @fields;
           ...
       } elsif ($event eq 'CACHE_STORE') { 
           my ($comp,$key) = @fields;
           ...
       } elsif ($event eq 'COMP_LOAD') {
           my ($comp) = @fields;
           ...
       } else {
           warn &quot;unrecognized event type: $event\n&quot;;
       }
   }
   
</PRE>

<P>

<STRONG>Suggested Uses</STRONG>




<P>

Performance: REQUEST events are useful for analyzing the performance of all
Mason requests occurring on your site, and identifying the slowest
requests. <CODE>eg/perflog.pl</CODE> in the Mason distribution is a log parser that outputs the average compute
time of each unique URL, in order from slowest to quickest.


<P>

Server activity: REQUEST events are useful for determining what your web
server children are working on, especially when you have a runaway. For a
given process, simply tail the log and find the last REQ_START event with
that process id. (You can also use the Apache status page for this.)


<P>

Cache efficiency: CACHE events are useful for monitoring cache ``hit
rates'' (number of successful reads over total number of reads) over all
components that use a data cache. Because stores to a cache are more
expensive than reads, a high hit rate is essential for the cache to have a
beneficial effect. If a particular cache hit rate is too low, you may want
to consider changing how frequently it is expired or whether to use it at
all.


<P>

Load frequency: COMP_LOAD events are useful for monitoring your code cache.
Too many loads may indicate that your code cache is too small. Also, if you
can turn off the code cache for a short time, COMP_LOAD events will tell
you which components are loaded most often and thus good candidates for
preloading.


<P>

<P>
<HR>
<H1><A NAME="performance_tuning">PERFORMANCE TUNING

</A></H1>
This section explains Mason's various performance enhancements and how to
administer them.


<P>

<P>
<HR>
<H2><A NAME="code_cache">Code cache

</A></H2>
When Mason loads a component, it places it in a memory cache.


<P>

The maximum size of the cache is specified with the
<A HREF="./Interp.html#item_code_cache_max_size">code_cache_max_size</A> Interp parameter; default is 10MB. When the cache fills up, Mason frees up
space by discarding a number of components. The discard algorithm is least
frequently used (LFU), with a periodic decay to gradually eliminate old
frequency information. In a nutshell, the components called most often in
recent history should remain in the cache. Very large components (over 20%
of the maximum cache size) never get cached, on the theory that they would
force out too many other components.


<P>

Note that the ``size'' of a component in memory cannot literally be
measured. It is estimated by the length of the source text plus some
overhead. Your process growth will not match the code cache size exactly.


<P>

You can monitor the performance of the memory cache by turning on
<A HREF="#system_logs">system logs</A> and counting the COMP_LOAD events. If these are occurring frequently even
for a long-running process, you may want to increase the size of your code
cache.


<P>

You can prepopulate the cache with components that you know will be
accessed often; see <A HREF="#preloading">Preloading</A>. Note that preloaded components possess no special status in the cache and
can be discarded like any others.


<P>

Naturally, a cache entry is invalidated if the corresponding component
source file changes.


<P>

To turn off code caching completely, set <A HREF="./Interp.html#item_code_cache_max_size">code_cache_max_size</A> to 0.


<P>

<P>
<HR>
<H2><A NAME="object_files">Object files

</A></H2>
The in-memory code cache is only useful on a per-process basis. Each
process must build and maintain its own cache. Shared memory caches are
conceivable in the future, but even those will not survive between web
server restarts.


<P>

As a secondary, longer-term cache mechanism, Mason stores a compiled form
of each component in an object file under
<CODE>data_dir/obj/<EM>component-path</EM></CODE>. Any server process can eval the object file and save time on parsing the
component source file. The object file is recreated whenever the source
file changes.


<P>

Besides improving performance, object files are essential for debugging and
interpretation of errors. Line numbers in error messages are given in terms
of the object file. The curious-minded can peek inside an object file to
see exactly how Mason converted a given component to a Perl object.


<P>

If you change any Parser options, you must remove object files previously
created under that parser for the changes to take effect.


<P>

If for some reason you don't want Mason to create object files, set the <A HREF="./Interp.html#item_use_object_files">use_object_files</A> Interp parameter to 0.


<P>

<P>
<HR>
<H2><A NAME="preloading">Preloading

</A></H2>
You can tell Mason to preload a set of components in the parent process,
rather than loading them on demand, using the
<A HREF="./Interp.html#item_preloads">preloads</A> Interp parameter. Each child server will start with those components loaded
in the memory cache. The trade-offs are:


<P>

<DL>
<DT><STRONG><A NAME="item_time">time

</A></STRONG><DD>
a small one-time startup cost, but children save time by not having to load
the components


<P>

<DT><STRONG><A NAME="item_memory">memory

</A></STRONG><DD>
a fatter initial server, but the memory for preloaded components are shared
by all children. This is similar to the advantage of using modules only in
the parent process.


<P>

</DL>
Try to preload components that are used frequently and do not change often.
(If a preloaded component changes, all the children will have to reload it
from scratch.)


<P>

<P>
<HR>
<H2><A NAME="reload_file">Reload file

</A></H2>
Normally, every time Mason executes a component, it checks the last
modified time of its source file to see if it needs to be reloaded. These
file checks are convenient for development, but for a production site they
degrade performance unnecessarily.


<P>

To remedy this, Mason has an accelerated mode that changes its behavior in
two ways:


<P>

1. Does not check component source files at all, relying solely on object
files. This means the developer or an automated system is responsible for
recompiling any components that change and recreating object files, using
the <A HREF="./Parser.html#item_make_component">make_component</A> Parser method.


<P>

2. Rather than continuously checking whether object files have changed,
Mason monitors a ``reload file'' containing an ever-growing list of
components that have changed. Whenever a component changes, the developer
or an automated system is responsible for appending the component path to
the reload file. The reload file is kept in
<CODE>data_dir/etc/reload.lst</CODE>.


<P>

You can activate this mode with the <A HREF="./Interp.html#item_use_reload_file">use_reload_file</A>
Interp method.


<P>

The advantage of using this mode is that Mason stats one file per request
instead of ten or twenty. The disadvantage is a increase in maintenance
costs as the object and reload files have to be kept up-to-date. Automated
editorial tools, and cron jobs that periodically scan the component
hierarchy for changes, are two possible solutions. The Mason content
management system automatically handles this task.


<P>

<P>
<HR>
<H1><A NAME="staging_vs_production">STAGING vs. PRODUCTION

</A></H1>
Site builders often maintain two versions of their sites: the production
(published) version visible to the world, and the development (staging)
version visible internally. Developers try out changes on the staging site
and push the pages to production once they are satisfied.


<P>

The priorities for the staging site are rapid development and easy
debugging, while the main priority for the production site is performance.
This section describes various ways to adapt Mason for each case.


<P>

<P>
<HR>
<H2><A NAME="out_mode">Out mode

</A></H2>
Mason can spew data in two modes. In ``batch'' mode Mason computes the
entire page in a memory buffer and then transmits it all at once. In
``stream'' mode Mason outputs data as soon as it is computed. (This does
not take into account buffering done by Apache or the O/S.) The default
mode is ``batch''.


<P>

Batch mode has the advantage of better error handling. Suppose an error
occurs in the middle of a page. In stream mode, the error message
interrupts existing output, often appearing in an awkward HTML context such
as the middle of a table which never gets closed. In batch mode, the error
message is output neatly and alone.


<P>

Batch mode also offers more flexibility in controlling HTTP headers (see <A HREF="././Devel.html#sending_http_headers">sending_http_headers</A>) and in handling mid-request error conditions (see <A HREF="././Request.html#clear_buffer">clear_buffer</A>).


<P>

Stream mode may help get data to the browser more quickly, allowing server
and browser to work in parallel. It also prevents memory buildup for very
large responses.


<P>

Since Apache does its own buffering, stream mode does not entail immediate
delivery of output to the client. You must set $|=1 to turn off Apache
buffering completely (generally not a good idea) or call
<CODE>$m-&gt;flush_buffer</CODE> to flush the buffer selectively.


<P>

In terms of making your server seem responsive, the initial bytes are most
important. You can send these early by calling <CODE>$m-&gt;flush_buffer</CODE>
in key locations such as the common page header. However, this dilutes the
advantages of batch mode mentioned above. Tradeoffs...


<P>

You control output mode by setting <CODE>interp-&gt;out_mode</CODE> to ``batch'' or ``stream''.


<P>

<P>
<HR>
<H2><A NAME="error_mode">Error mode

</A></H2>
When an error occurs, Mason can respond by:


<P>

<UL>
<LI><STRONG></STRONG>
showing a detailed error message in the browser


<P>

<LI><STRONG></STRONG>
die'ing, which sends a 501 to the browser and lets the error message go to
the error logs.


<P>

</UL>
The first option is ideal for development, where you want immediate
feedback on the error. The second option is usually desired for production
so that users are not exposed to messy error messages. You control this
option by setting ah-&gt;error_mode to ``html'' or ``fatal'' respectively.


<P>

<P>
<HR>
<H2><A NAME="debug_mode">Debug mode

</A></H2>
As discussed in the debugging section, you can control when Mason creates a
debug file. While creating a debug file is not incredibly expensive, it
does involves a bit of work and the creation of a new file, so you probably
want to avoid doing it on every request to a frequently visited site. I
recommend setting debug_mode to 'all' in development, and 'error' or 'none'
in production.


<P>

<P>
<HR>
<H2><A NAME="reload_files">Reload files

</A></H2>
Consider reload files only for frequently visited production sites.


<P>

<P>
<HR>
<H1><A NAME="configuring_virtual_sites">CONFIGURING VIRTUAL SITES

</A></H1>
These examples extend the single site configurations given so far.


<P>

<P>
<HR>
<H2><A NAME="multiple_sites_one_component_ro">Multiple sites, one component root

</A></H2>
If you want to share some components between your sites, arrange your
httpd.conf so that all DocumentRoots live under a single component space:


<P>

<PRE>    # Web site #1
    &lt;VirtualHost www.site1.com&gt;
        DocumentRoot /usr/local/www/htdocs/site1
        &lt;Location /&gt;
            SetHandler perl-script
            PerlHandler HTML::Mason
        &lt;/Location&gt;
    &lt;/VirtualHost&gt;
</PRE>

<P>

<PRE>    # Web site #2
    &lt;VirtualHost www.site2.com&gt;
        DocumentRoot /usr/local/www/htdocs/site2
        &lt;Location /&gt;
            SetHandler perl-script
            PerlHandler HTML::Mason
        &lt;/Location&gt;
    &lt;/VirtualHost&gt;
</PRE>

<P>

<PRE>    # Mason configuration
    MasonCompRoot &quot;/usr/local/www/htdocs&quot;
    MasonDataDir &quot;/usr/local/mason&quot;
</PRE>

<P>

The directory structure for this scenario might look like:


<P>

<PRE>    /usr/local/www/htdocs/  # component root
        +- shared/          # shared components
        +- site1/           # DocumentRoot for first site
        +- site2/           # DocumentRoot for second site
</PRE>

<P>

Incoming URLs for each site can only request components in their respective
DocumentRoots, while components internally can call other components
anywhere in the component space. The shared/ directory is a private
directory for use by components, inaccessible from the Web.


<P>

<P>
<HR>
<H2><A NAME="multiple_sites_multiple_compone">Multiple sites, multiple component roots

</A></H2>
Sometimes your sites need to have completely distinct component
hierarchies, e.g. if you are providing Mason ISP services for multiple
users. In this case the component root must change depending on the site
requested. Since you can't change an interpreter's component root
dynamically, you need to maintain separate Mason objects for each site in
your <CODE>handler.pl</CODE>:


<P>

<PRE>    my (%interp,%ah);
    foreach my $site (qw(site1 site2 site3)) {
        $interp{$site} = new HTML::Mason::Interp
            (comp_root =&gt; &quot;/usr/local/www/$site&quot;,
             data_dir =&gt; &quot;/usr/local/mason/$site&quot;);
        $ah{$site} = new HTML::Mason::ApacheHandler
            (interp =&gt; $interp{$site});
    }
</PRE>

<P>

<PRE>    ...
</PRE>

<P>

<PRE>    sub handler {
        my ($r) = @_;
        my $site = $r-&gt;dir_config('site');
        $ah{$site}-&gt;handle_request($r);
    }
</PRE>

<P>

We assume each virtual server configuration section has a


<P>

<PRE>    PerlSetVar site &lt;site_name&gt;
</PRE>

<P>

Above we pre-create all Mason objects in the parent. Another scheme is to
create objects on demand in the child:


<P>

<PRE>    my (%interp,%ah);
</PRE>

<P>

<PRE>    ...
</PRE>

<P>

<PRE>    sub handler {
        my ($r) = @_;        
        my $site = $r-&gt;dir_config('site');
        unless exists($interp{$site}) {
            # get comp_root from PerlSetVar as well
            my $comp_root = $r-&gt;dir_config('comp_root');
            $interp{$site} = new HTML::Mason::Interp(comp_root=&gt;$comp_root,...);
            $ah{$site} = new HTML::Mason::ApacheHandler(interp=&gt;$interp{$site},...);
        }
    }
</PRE>

<P>

The advantage of the second scheme is that you don't have to hardcode as
much information in the <CODE>handler.pl</CODE>. The disadvantage is a slight memory and performance impact. On
development servers this shouldn't matter; on production servers you may
wish to profile the two schemes.


<P>

<P>
<HR>
<H1><A NAME="authors">AUTHORS

</A></H1>
Jonathan Swartz, <A HREF="MAILTO:swartz@pobox.com">swartz@pobox.com</A> and
Dave Rolsky, <A HREF="MAILTO:autarch@urth.org">autarch@urth.org</A>


<P>

<P>
<HR>
<H1><A NAME="see_also">SEE ALSO

</A></H1>
<A HREF="././Mason.html#">HTML::Mason</A>,
<A HREF="././Parser.html#">HTML::Mason::Parser</A>,
<A HREF="././Interp.html#">HTML::Mason::Interp</A>,
<A HREF="././ApacheHandler.html#">HTML::Mason::ApacheHandler</A>




<P>

</DL>
    </BODY>

    </HTML>
