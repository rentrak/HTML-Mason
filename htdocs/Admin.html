<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>HTML::Mason::Admin - Mason Administrator's Manual</title>
<link rev="made" href="mailto:root@localhost" />
</head>

<body style="background-color: white">

<p><A NAME="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><A HREF="#name">NAME</a></li>
	<li><A HREF="#description">DESCRIPTION</a></li>
	<li><A HREF="#site_configuration_methods">SITE CONFIGURATION METHODS</a></li>
	<li><A HREF="#basic_configuration_via_httpd_co">BASIC CONFIGURATION VIA httpd.conf DIRECTIVES</a></li>
	<ul>

		<li><A HREF="#controlling_access_via_filename_">Controlling Access via Filename Extension</a></li>
		<li><A HREF="#configuration_parameters">Configuration Parameters</a></li>
	</ul>

	<li><A HREF="#general_server_configuration">GENERAL SERVER CONFIGURATION</a></li>
	<ul>

		<li><A HREF="#component_root">Component Root</a></li>
		<li><A HREF="#data_directory">Data Directory</a></li>
		<li><A HREF="#external_modules">External Modules</a></li>
		<li><A HREF="#allowing_directory_requests">Allowing Directory Requests</a></li>
		<li><A HREF="#configuring_virtual_sites">Configuring Virtual Sites</a></li>
		<ul>

			<li><A HREF="#multiple_sites__one_component_ro">Multiple sites, one component root</a></li>
			<li><A HREF="#multiple_sites__multiple_compone">Multiple sites, multiple component roots</a></li>
		</ul>

	</ul>

	<li><A HREF="#advanced_configuration">ADVANCED CONFIGURATION</a></li>
	<ul>

		<li><A HREF="#writing_a_wrapper">Writing a Wrapper</a></li>
		<li><A HREF="#wrapping_with_a__perl__block">Wrapping with a &lt;Perl&gt; block</a></li>
		<li><A HREF="#wrapping_with_a_module">Wrapping with a Module</a></li>
		<li><A HREF="#the_wrapper_code">The Wrapper Code</a></li>
		<li><A HREF="#external_modules_revisited">External Modules Revisited</a></li>
		<ul>

			<li><A HREF="#example__controlling_access_with">Example: Controlling access with component attributes</a></li>
		</ul>

		<li><A HREF="#wrappers_with_virtual_hosts">Wrappers with Virtual Hosts</a></li>
		<ul>

			<li><A HREF="#creating_apachehandler_objects_o">Creating apachehandler objects on the fly</a></li>
			<li><A HREF="#other_uses_for_a_wrapper">Other uses for a wrapper</a></li>
		</ul>

		<li><A HREF="#mixing_httpd_conf_configuration_">Mixing httpd.conf Configuration with a Wrapper</a></li>
	</ul>

	<li><A HREF="#development">DEVELOPMENT</a></li>
	<ul>

		<li><A HREF="#global_variables">Global Variables</a></li>
		<li><A HREF="#sessions">Sessions</a></li>
		<li><A HREF="#data_caching">Data Caching</a></li>
	</ul>

	<li><A HREF="#performance">PERFORMANCE</a></li>
	<ul>

		<li><A HREF="#code_cache">Code Cache</a></li>
		<li><A HREF="#object_files">Object Files</a></li>
		<li><A HREF="#write_a_handler_subroutine">Write a handler subroutine</a></li>
		<li><A HREF="#static_source_mode">Static Source Mode</a></li>
		<li><A HREF="#preloading_components">Preloading Components</a></li>
	</ul>

	<li><A HREF="#error_reporting_and_exceptions">ERROR REPORTING AND EXCEPTIONS</a></li>
	<ul>

		<li><A HREF="#exceptions_under_the_hood">Exceptions Under the Hood</a></li>
		<ul>

			<li><A HREF="#calling_a_component_to_handle_er">Calling a Component to Handle Errors</a></li>
		</ul>

	</ul>

	<li><A HREF="#running_outside_of_mod_perl">RUNNING OUTSIDE OF MOD_PERL</a></li>
	<ul>

		<li><A HREF="#using_mason_from_a_cgi_script">Using Mason from a CGI Script</a></li>
		<li><A HREF="#using_mason_from_a_standalone_sc">Using Mason from a Standalone Script</a></li>
	</ul>

	<li><A HREF="#authors">AUTHORS</a></li>
	<li><A HREF="#see_also">SEE ALSO</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<h1><A NAME="name">NAME</a></h1>
<p>HTML::Mason::Admin - Mason Administrator's Manual</p>
<p>
</p>
<hr />
<h1><A NAME="description">DESCRIPTION</a></h1>
<p>This manual is written for the sysadmin/webmaster in charge of
installing, configuring, or tuning a Mason system.  The bulk of the
documentation assumes that you are using mod_perl.  See <A HREF="Admin.html#running_outside_of_mod_perl">RUNNING OUTSIDE OF MOD_PERL</a>
for more details. For more details on mod_perl, visit
the mod_perl website at <a href="http://perl.apache.org/.">http://perl.apache.org/.</a></p>
<p>
</p>
<hr />
<h1><A NAME="site_configuration_methods">SITE CONFIGURATION METHODS</a></h1>
<p>Mason includes module specifically designed to integrate Mason and
mod_perl, <code>HTML::Mason::ApacheHandler</code>.  By telling mod_perl to hand
content requests to this module, you can use Mason to generate web
pages.  There are two ways to configure Mason under mod_perl.</p>
<ul>
<li><strong><A NAME="item_basic">Basic</a></strong><br />
</li>
Mason provides reasonable default behavior under mod_perl, so using
Mason can be as simple as adding two directives to your Apache
configuration file.  Throughout this document, we will assume that
your Apache configuration file is called <em>httpd.conf</em>.  By adding
more configuration parameters to this file you can implement more
complex behaviors.
<p></p>
<li><strong><A NAME="item_advanced">Advanced</a></strong><br />
</li>
If the basic method does not provide enough flexibility for you, you
can wrap Mason in a custom mod_perl handler.  The wrapper code you
write can create its own Mason objects, or it can take advantage of
<em>httpd.conf</em> configuration parameters and let Mason create the
objects it needs by itself.
<p></p></ul>
<p>We recommend that you start with the basic method and work your way
forward as the need for flexibility arises.</p>
<p>Mason is very flexible, and you can replace parts of it by creating
your own classes.  This documentation assumes that you are simply
using the classes provided in the Mason distribution.  Subclassing is
covered in the <a HREF="Subclassing.html">Subclassing</a> document.  The
two topics are orthogonal, as you can mix the configuration techniques
discussed here with your own custom subclasses.</p>
<p>
</p>
<hr />
<h1><A NAME="basic_configuration_via_httpd_co">BASIC CONFIGURATION VIA httpd.conf DIRECTIVES</a></h1>
<p>The absolutely most minimal configuration looks like this:</p>
<pre>
    PerlModule HTML::Mason::ApacheHandler</pre>
<pre>
    &lt;Location /&gt;
      SetHandler   perl-script
      PerlHandler  HTML::Mason::ApacheHandler
    &lt;/Location&gt;</pre>
<p>This configuration tells Apache to serve all URLs through Mason (see
the next section for a more realistic strategy).  We use the
PerlModule line to tell mod_perl to load Mason once at startup time,
saving time and memory.  This example does not set any Mason
configuration parameters, so Mason uses its default values.</p>
<p>If this is your first time installing and using Mason, we recommend
that you use the above configuration in a test webserver to start
with.  This will let you play with Mason under mod_perl with a minimum
of fuss.  Once you've gotten this working, then come back and read the
rest of the document for further possibilities.</p>
<p>
</p>
<h2><A NAME="controlling_access_via_filename_">Controlling Access via Filename Extension</a></h2>
<p>As it turns out, serving every URL through Mason is a bad idea for two
reasons:</p>
<ol>
<li></li>
Mason should be prevented from handling images, tarballs, and other
binary files. Not only will performance suffer, but binary files may
inadvertently contain a Mason character sequence such as ``&lt;%''. These
files should be instead served by Apache's default content handler.
<p></p>
<li></li>
Mason should be prevented from serving private (non-top-level) Mason
components to users. For example, if you used a utility component for
performing arbitrary sql queries, you wouldn't want external users to
be able to access it via a URL. Requests for private components should
simply result in a 404 NOT_FOUND.
<p></p></ol>
<p>The easiest way to distinguish between different types of files is
with filename extensions. While many naming schemes are possible, we
suggest using ``normal'' extensions for top-level components and
adding an ``m'' prefix for private components. For example,</p>
<pre>
                             Top-level       Private</pre>
<pre>
   Component outputs HTML    .html           .mhtml
   Component outputs text    .txt            .mtxt
   Component executes Perl   .pl             .mpl</pre>
<p>This scheme minimizes the chance of confusing browsers about content
type, scales well for new classes of content (e.g. .js/.mjs for
javascript), and makes transparent the fact that you are using Mason
versus some other package.</p>
<p>Here is a configuration that enforces this naming scheme:</p>
<pre>
    PerlModule HTML::Mason::ApacheHandler</pre>
<pre>
    &lt;LocationMatch &quot;(\.html|\.txt|\.pl)$&quot;&gt;
      SetHandler perl-script
      PerlHandler HTML::Mason::ApacheHandler
    &lt;/LocationMatch&gt;</pre>
<pre>
    &lt;LocationMatch &quot;(\.m(html|txt|pl)|dhandler|autohandler)$&quot;&gt;
      SetHandler perl-script
      PerlInitHandler Apache::Constants::NOT_FOUND
    &lt;/LocationMatch&gt;</pre>
<p>The first block causes URLs ending in .html, .txt, or .pl to be served
through Mason. The second block causes requests to private components
to return 404 NOT_FOUND, preventing unscrupulous users from even
knowing which private components exist. Any other file extensions
(e.g. .gif, .tgz) will be served by Apache's default content handler.</p>
<p>You might prefer <code>FilesMatch</code> to <code>LocationMatch</code>. However, be aware
that <code>LocationMatch</code> will work best in conjunction with Mason's
<A HREF="Devel.html#dhandlers">dhandlers</a>.</p>
<p>
</p>
<h2><A NAME="configuration_parameters">Configuration Parameters</a></h2>
<p>Mason allows you to flexibly configure its behavior via <em>httpd.conf</em>
configuration parameters.</p>
<p>These configuration parameters are set via mod_perl's <code>PerlSetVar</code>
and <code>PerlAddVar</code> directives (the latter is only available in mod_perl
version 1.24 and greater).  Though these parameters are all strings in
your <em>httpd.conf</em> file, Mason treats different directives as
containing different types of values:</p>
<ul>
<li><strong><A NAME="item_string">string</a></strong><br />
</li>
The variable's value is simply taken literally and used.  The string
should be surrounded by quotes if the it contains whitespace.  The
quotes will be automatically removed by Apache before Mason sees the
variable.
<p></p>
<li><strong><A NAME="item_boolean">boolean</a></strong><br />
</li>
The variable's value is used as a boolean, and is subject to Perl's
rules on truth/falseness.  It is recommended that you use 0 (false) or
1 (true) for these arguments.
<p></p>
<li><strong><A NAME="item_code">code</a></strong><br />
</li>
The string is treated as a piece of code and <code>eval</code>'ed.  This is used
for parameters that expect subroutine references.  For example, an
anonymous subroutine might look like:
<pre>
 PerlSetVar  MasonOutMode  &quot;sub { ... }&quot;</pre>
<p>A named subroutine reference would look like this:</p>
<pre>
 PerlSetVar  MasonOutMode  &quot;\&amp;Some::Module::handle_output&quot;</pre>
<p></p>
<li><strong><A NAME="item_list">list</a></strong><br />
</li>
To set a list parameter, use <code>PerlAddVar</code> for the values, like this:
<pre>
 PerlAddVar  MasonPreloads  /foo/bar/baz.comp
 PerlAddVar  MasonPreloads  /foo/bar/quux.comp</pre>
<p>As noted above, <code>PerlAddVar</code> is only available in mod_perl 1.24 and
up.  This means that it is only possible to assign a single value
(using <code>PerlSetVar</code>) to list parameters if you are using a mod_perl
older than 1.24.</p>
<p></p>
<li><strong><A NAME="item_hash_list">hash_list</a></strong><br />
</li>
Just like a list parameter, use <code>PerlAddVar</code> for the values.
However, in the case of a hash_list, each element should be a
key/value pair separated by ``=&gt;'':
<pre>
 PerlAddVar  MasonDataCacheDefaults  &quot;cache_class =&gt; MemoryCache&quot;
 PerlAddVar  MasonDataCacheDefaults  &quot;namespace =&gt; foo&quot;</pre>
<p>Take note that the right hand side of the each pair should <em>not</em> be
quoted.</p>
<p></p></ul>
<p>See <a HREF="Params.html">HTML::Mason::Params</a> for a full list
of parameters, and their associated types.</p>
<p>
</p>
<hr />
<h1><A NAME="general_server_configuration">GENERAL SERVER CONFIGURATION</a></h1>
<p>
</p>
<h2><A NAME="component_root">Component Root</a></h2>
<p>The component root (<A HREF="Params.html#comp_root">comp_root</a>) marks the top of your component
hierarchy.  When running Mason with the ApacheHandler or CGIHandler
modules, this defaults to your document root.</p>
<p>The component root defines how component paths are translated into
real file paths. If your component root is <em>/usr/local/httpd/docs</em>, a
component path of <em>/products/index.html</em> translates to the file
<em>/usr/local/httpd/docs/products/index.html</em>.</p>
<p>One cannot call a component outside the component root. If Apache
passes a file through Mason that is outside the component root (say,
as the result of an Alias) you will get a 404 and a warning in the
logs.</p>
<p>You may also specify multiple component roots in the spirit of Perl's
<code>@INC</code>. Each root is assigned a key that identifies the root
mnemonically. For example, in <em>httpd.conf</em>:</p>
<pre>
    PerlAddVar  MasonCompRoot  &quot;private =&gt; /usr/home/joe/comps&quot;
    PerlAddVar  MasonCompRoot  &quot;main =&gt; /usr/local/www/htdocs&quot;</pre>
<p>This specifies two component roots, a main component tree and a
private tree which overrides certain components.  The order is
respected ala <code>@INC</code>, so <em>private</em> is searched first and <em>main</em>
second.</p>
<p>The component root keys must be unique in a case-insensitive
comparison.</p>
<p>
</p>
<h2><A NAME="data_directory">Data Directory</a></h2>
<p>The data directory (<A HREF="Params.html#data_dir">data_dir</a>) is a writable directory that Mason
uses for various features and optimizations. By default, it is a
directory called ``mason'' under your Apache server root.  Because Mason
will not use a <em>default</em> data directory under a top-level directory,
you will need to change this on certain systems that assign a
high-level server root such as <em>/usr</em> or <em>/etc</em>.</p>
<p>Mason will create the directory on startup, if necessary, and set its
permissions according to the web server User/Group.</p>
<p>
</p>
<h2><A NAME="external_modules">External Modules</a></h2>
<p>Components will often need access to external Perl modules. There are
several ways to load them.</p>
<ul>
<li></li>
The httpd PerlModule directive:
<pre>
    PerlModule CGI
    PerlModule LWP</pre>
<p></p>
<li></li>
In the <code>&lt;%once&gt;</code> section of the <code>component(s)</code> that use the module.
<pre>
    &lt;%once&gt;
    use CGI ':standard';
    use LWP;
    &lt;/%once&gt;</pre>
<p></p></ul>
<p>Each method has its own trade-offs:</p>
<p>The first method ensures that the module will be loaded by the Apache
parent process at startup time, saving time and memory.  The second
method, in contrast, will cause the modules to be loaded by each
server child. On the other hand this could save memory if the
component and module are rarely used. See the mod_perl guide's tuning
section and Vivek Khera's mod_perl tuning guide for more details on
this issue.</p>
<p>The second method uses the modules from inside the package used by
components (<code>HTML::Mason::Commands</code>), meaning that exported method
names and other symbols will be usable from components.  The first
method, in contrast, will import symbols into the <code>main</code> package. The
significance of this depends on whether the modules export symbols and
whether you want to use them from components.</p>
<p>If you want to preload the modules in your <em>httpd.conf</em> file, and
still have them export symbols into the <code>HTML::Mason::Commands</code>
namespace, you can do this:</p>
<pre>
  &lt;Perl&gt;
  { package HTML::Mason::Commands;
    use CGI;
    use LWP;
  }
  &lt;/Perl&gt;</pre>
<p>A Perl section will also work for including local library paths:</p>
<pre>
  &lt;Perl&gt;
  use lib '/path/to/local/lib';
  &lt;/Perl&gt;</pre>
<p>
</p>
<h2><A NAME="allowing_directory_requests">Allowing Directory Requests</a></h2>
<p>By default Mason will decline requests for directories, leaving Apache
to serve up a directory index or a FORBIDDEN as appropriate.
Unfortunately this rule applies even if there is a dhandler in the
directory: <em>/foo/bar/dhandler</em> does not get a chance to
handle a request for <em>/foo/bar/</em>.</p>
<p>If you would like Mason to handle directory requests, set
<A HREF="Params.html#decline_dirs">decline_dirs</a> to 0.  The dhandler that catches a directory request
is responsible for setting a reasonable content type via
<code>$r-&gt;content_type()</code></p>
<p>
</p>
<h2><A NAME="configuring_virtual_sites">Configuring Virtual Sites</a></h2>
<p>These examples extend the single site configurations given so far.</p>
<p>
</p>
<h3><A NAME="multiple_sites__one_component_ro">Multiple sites, one component root</a></h3>
<p>If you want to share some components between your sites, arrange your
<em>httpd.conf</em> so that all DocumentRoots live under a single component
space:</p>
<pre>
    # Web site #1
    &lt;VirtualHost www.site1.com&gt;
      DocumentRoot  /usr/local/www/htdocs/site1
      &lt;LocationMatch ...&gt;
        SetHandler   perl-script
        PerlHandler  HTML::Mason::ApacheHandler
      &lt;/LocationMatch&gt;
    &lt;/VirtualHost&gt;</pre>
<pre>
    # Web site #2
    &lt;VirtualHost www.site2.com&gt;
      DocumentRoot  /usr/local/www/htdocs/site2
      &lt;LocationMatch ...&gt;
        SetHandler   perl-script
        PerlHandler  HTML::Mason::ApacheHandler
      &lt;/LocationMatch&gt;
    &lt;/VirtualHost&gt;</pre>
<pre>
    # Mason configuration
    PerlSetVar  MasonCompRoot  /usr/local/www/htdocs
    PerlSetVar  MasonDataDir   /usr/local/mason
    PerlModule  HTML::Mason::ApacheHandler</pre>
<p>The directory structure for this scenario might look like:</p>
<pre>
    /usr/local/www/htdocs/  # component root
        +- shared/          # shared components
        +- site1/           # DocumentRoot for first site
        +- site2/           # DocumentRoot for second site</pre>
<p>Incoming URLs for each site can only request components in their
respective DocumentRoots, while components internally can call other
components anywhere in the component space. The <em>shared/</em> directory
is a private directory for use by components, inaccessible from the
Web.</p>
<p>
</p>
<h3><A NAME="multiple_sites__multiple_compone">Multiple sites, multiple component roots</a></h3>
<p>If your sites need to have completely distinct component hierarchies,
e.g. if you are providing Mason ISP services for multiple users, then
the component root must change depending on the site requested.</p>
<pre>
    &lt;VirtualHost www.site1.com&gt;
      DocumentRoot  /usr/local/www/htdocs/site1</pre>
<pre>
      # Mason configuration
      PerlSetVar  MasonCompRoot    /usr/local/www/htdocs/site1
      PerlSetVar  MasonDataDir     /usr/local/mason/site1</pre>
<pre>
      &lt;LocationMatch ...&gt;
        SetHandler   perl-script
        PerlHandler  HTML::Mason::ApacheHandler
      &lt;/LocationMatch&gt;
    &lt;/VirtualHost&gt;</pre>
<pre>
    # Web site #2
    &lt;VirtualHost www.site2.com&gt;
      DocumentRoot  /usr/local/www/htdocs/site2</pre>
<pre>
      # Mason configuration
      PerlSetVar  MasonCompRoot    /usr/local/www/htdocs/site2
      PerlSetVar  MasonDataDir     /usr/local/mason/site2</pre>
<pre>
      &lt;LocationMatch ...&gt;
        SetHandler   perl-script
        PerlHandler  HTML::Mason::ApacheHandler
      &lt;/LocationMatch&gt;
    &lt;/VirtualHost&gt;</pre>
<p>
</p>
<hr />
<h1><A NAME="advanced_configuration">ADVANCED CONFIGURATION</a></h1>
<p>As mentioned previously, it is possible to write a custom mod_perl
content handler that wraps around Mason and provides basically
unlimited flexibility when handling requests.  In this section, we
show some basic wrappers and re-implement some of the functionality
previously discussed, such as declining image requests and protecting
private components.</p>
<p>In addition, we discuss some of the possibilities that become
available when you create a custom wrapper around Mason's request
handling mechanism.  This wrapper generally consists of two parts.
The initialization portion, run at server startup, will load any
needed modules and create objects.  The other portion is the
<code>handler()</code> subroutine, which handles web page requests.</p>
<p>
</p>
<h2><A NAME="writing_a_wrapper">Writing a Wrapper</a></h2>
<p>To create a wrapper, you simply need to define a <code>handler()</code>
subroutine in the package of your choice, and tell mod_perl to use it
as a content handler.  The file that defines the <code>handler()</code>
subroutine can be a module, or you can simply load a simple file that
contains this subroutine definition.  The latter solution was, for a
long time, the <em>only</em> way to configure Mason, and the file used was
traditionally called <em>handler.pl</em>.  This file was usually placed in
the Apache configuration directory and was loaded like this:</p>
<pre>
  PerlRequire  handler.pl</pre>
<p>The <em>eg/</em> directory of the Mason distribution contains a couple
sample <em>handler.pl</em> scripts.  Let's assume that your script, like the
example script, defines a handler in the package <code>MyApp::Mason</code>.  In
this case, your Apache configuration would look like this:</p>
<pre>
  PerlRequire  handler.pl</pre>
<pre>
  &lt;LocationMatch ...&gt;
    SetHandler   perl-script
    PerlHandler  MyApp::Mason
  &lt;/LocationMatch&gt;</pre>
<p>You may still see references to a <em>handler.pl</em> file in the Mason
users list archives, as well as the FAQ.  These references will
generally be applicable to any custom code wrapping Mason.</p>
<p>
</p>
<h2><A NAME="wrapping_with_a__perl__block">Wrapping with a &lt;Perl&gt; block</a></h2>
<p>You can also put your wrapper code in a <code>&lt;Perl&gt;</code> block as part of
your <em>httpd.conf</em> file.  The result is no different than loading a
file via the <code>PerlRequire</code> directive.</p>
<p>
</p>
<h2><A NAME="wrapping_with_a_module">Wrapping with a Module</a></h2>
<p>Remember, this wrapper code doesn't <em>have</em> to be in a file
<em>handler.pl</em>.  You could just as easily create an actual module
called <code>MyApp::Mason</code>, install it just like any other module, and
load it with:</p>
<pre>
  PerlModule  MyApp::Mason</pre>
<p>The advantage to this approach is that it uses well-known techniques
for creating and installing modules, but it does require a bit more
work than simply dropping a <em>handler.pl</em> file into the Apache
configuration directory.  But because the process is better defined,
it may ``feel'' more solid to some folks than the <em>handler.pl</em>
approach.</p>
<p>
</p>
<h2><A NAME="the_wrapper_code">The Wrapper Code</a></h2>
<p>Regardless of how you load your wrapper code, it will always work the
same way.  The <code>handler()</code> subroutine should expect to receive the
Apache request object representing the current request.  This request
object is used by the ApacheHandler module to determine what component
is being called.</p>
<p>Let's look at the guts of some wrapper code.  Here's a first version:</p>
<pre>
  package MyApp::Mason;</pre>
<pre>
  use strict;
  use HTML::Mason::ApacheHandler;</pre>
<pre>
  my $ah =
      HTML::Mason::ApacheHandler-&gt;new
          ( comp_root =&gt; '/path/to/comp/root',
            data_dir  =&gt; '/path/to/data/dir' );</pre>
<pre>
  sub handler {
      my ($r) = @_;</pre>
<pre>
      return $ah-&gt;handle_request($r);
  }</pre>
<p>This wrapper is fully functional, but it doesn't actually do anything
you couldn't do more easily by configuring Mason via the <em>httpd.conf</em>
file.  However, it does serve as a good skeleton to which additional
functionality can easily be added.</p>
<p>
</p>
<h2><A NAME="external_modules_revisited">External Modules Revisited</a></h2>
<p>Since you are loading an arbitrary piece of code to define your
wrapper, you can easily load other modules needed for your application
at the same time.  For example, you might simple add these lines to
the wrapper code above:</p>
<pre>
  {
      package HTML::Mason::Commands;</pre>
<pre>
      use MIME::Base64;
  }</pre>
<p>Explicitly setting the package to <code>HTML::Mason::Commands</code> makes sure
that any symbols that the loaded modules export (constants,
subroutines, etc.) get exported into the namespace under which
components run.  Of course, if you've changed the component namespace,
make sure to change the package name here as well.</p>
<p>Alternatively, you might consider creating a separate piece of code to
load the modules you need.  For example, you might create a module
called <code>MyApp::MasonInit</code>:</p>
<pre>
  {
      package HTML::Mason::Commands;</pre>
<pre>
      use Apache::Constants qw(:common);
      use Apache::URI;
      use File::Temp;
  }</pre>
<pre>
  1;</pre>
<p>This can be loaded via a <code>PerlModule</code> directive in the <em>httpd.conf</em>
file, or in the wrapper code itself via <code>use</code>.</p>
<p>
</p>
<h3><A NAME="example__controlling_access_with">Example: Controlling access with component attributes</a></h3>
<p>An example of something you can only do with wrapper code is deciding
at run-time whether a component can be accessed at the top-level based
on a complex property of the component.  For example, here's a piece
of code that uses the current user and a component's <code>access_level</code>
attribute to control access:</p>
<pre>
  sub handler {
      my ($r) = @_;</pre>
<pre>
      my $req = $ah-&gt;prepare_request($r);</pre>
<pre>
      my $comp = $req-&gt;request_comp;</pre>
<pre>
      # this is done via magic hand-waving ...
      my $user = get_user_from_cookie();</pre>
<pre>
      # remember, attributes are inherited so this could come from a
      # component higher up the inheritance chain
      my $required_access = $comp-&gt;attr('access_level');</pre>
<pre>
      return NOT_FOUND
          if $user-&gt;access_level &lt; $required_access;</pre>
<pre>
      return $req-&gt;exec;
  }</pre>
<p>
</p>
<h2><A NAME="wrappers_with_virtual_hosts">Wrappers with Virtual Hosts</a></h2>
<p>If you had several virtual hosts, each of which had a separate
component root, you'd need to create a separate ApacheHandler object
for each host, one for each host.  Here's some sample code for that:</p>
<pre>
    my %ah;
    foreach my $site ( qw( site1 site2 site3 ) ) {
        $ah{$site} =
            HTML::Mason::ApacheHandler-&gt;new
                ( comp_root =&gt; &quot;/usr/local/www/$site&quot;,
                  data_dir =&gt; &quot;/usr/local/mason/$site&quot; );
    }</pre>
<pre>
    sub handler {
        my ($r) = @_;</pre>
<pre>
        my $site = $r-&gt;dir_config('SiteName');</pre>
<pre>
        return DECLINED unless exists $ah{$site};</pre>
<pre>
        return $ah{$site}-&gt;handle_request($r);
    }</pre>
<p>This code assumes that you set the <code>SiteName</code> variable via a
<code>PerlSetVar</code> directive in each <code>VirtualHost</code> block, like this:</p>
<pre>
  &lt;VirtualHost site1.example.com&gt;
    PerlSetVar  SiteName  site1</pre>
<pre>
    &lt;LocationMatch ...&gt;
      SetHandler   perl-script
      PerlHandler  MyApp::Mason
    &lt;/LocationMatch&gt;
  &lt;/VirtualHost&gt;</pre>
<p>
</p>
<h3><A NAME="creating_apachehandler_objects_o">Creating apachehandler objects on the fly</a></h3>
<p>You might also consider creating ApacheHandler objects on the fly,
like this:</p>
<pre>
    my %ah;
    sub handler {
        my ($r) = @_;
        my $site = $r-&gt;dir_config('SiteName');</pre>
<pre>
        return DECLINED unless $site;</pre>
<pre>
        unless exists($ah{$site}) {
            $ah{$site} = HTML::Mason::ApacheHandler-&gt;new( ... );
        }</pre>
<pre>
        $ah{$site}-&gt;handle_request($r);
    }</pre>
<p>This is more flexible but you lose the memory savings of creating all
your objects during server startup.</p>
<p>
</p>
<h3><A NAME="other_uses_for_a_wrapper">Other uses for a wrapper</a></h3>
<p>If you have some code which must <em>always</em> run after a request, then
the only way to guarantee that this happens is to wrap the <code>$ah-&gt;handle_request()</code>
call in an <code>eval {}</code> block, and then run the
needed code after the request returns.  You can then handle errors
however you like.</p>
<p>
</p>
<h2><A NAME="mixing_httpd_conf_configuration_">Mixing httpd.conf Configuration with a Wrapper</a></h2>
<p>You can take advantage of Mason's <em>httpd.conf</em> configuration system
while at the same time providing your own wrapper code.  The key to
doing this is <em>not</em> creating your own ApacheHandler object.  Instead,
you call the <code>HTML::Mason::ApacheHandler-&gt;handler()</code> class method
from your <code>handler()</code> subroutine.  Here's a complete wrapper that
does this:</p>
<pre>
  package MyApp::Mason;</pre>
<pre>
  use strict;
  use HTML::Mason::ApacheHandler;</pre>
<pre>
  sub handler {
      my ($r) = @_;</pre>
<pre>
      return HTML::Mason::ApacheHandler-&gt;handler($r);
  }</pre>
<p>The <code>HTML::Mason::ApacheHandler-&gt;handler</code> method will create an
ApacheHandler object based on the configuration directives it finds in
your <em>httpd.conf</em> file.  Obviously, this wrapper is again a skeleton,
but you could mix and match this wrapper code with any of the code
shown above.</p>
<p>Alternately you could subclass the <code>HTML::Mason::ApacheHandler</code>
class, and override the <code>handler()</code> method it provides.  See the
<a HREF="Subclassing.html">Subclassing</a> documentation for more
details.  Of course, you could even create a subclass <em>and</em> write a
wrapper that called it.</p>
<p>
</p>
<hr />
<h1><A NAME="development">DEVELOPMENT</a></h1>
<p>This section describes how to set up common developer features.</p>
<p>
</p>
<h2><A NAME="global_variables">Global Variables</a></h2>
<p>Global variables can make programs harder to read, maintain, and
debug, and this is no less true for Mason components.  Due to the
persistent mod_perl environment, globals require extra initialization
and cleanup care.</p>
<p>That said, there are times when it is very useful to make a value
available to all Mason components: a DBI database handle, a hash of
user session information, the server root for forming absolute URLs.</p>
<p>Because Mason by default parses components in <code>strict</code> mode, you'll
need to declare a global if you don't want to access it with an
explicit package name. The easiest way to declare a global is with
the <A HREF="Params.html#allow_globals">allow_globals</a> parameter.</p>
<p>Since all components run in the same package, you'll be able to set
the global in one component and access it in all the others.</p>
<p>Autohandlers are common places to assign values to globals.  Use the
<code>&lt;%once&gt;</code> section if the global only needs to be
initialized at load time, or the <code>&lt;%init&gt;</code> section if it
needs to be initialized every request.</p>
<p>
</p>
<h2><A NAME="sessions">Sessions</a></h2>
<p>Mason does not have a built-in session mechanism, but you can use the
<code>MasonX::Request::WithApacheSession</code> module, available from CPAN, to
add a session to every request.  It can also automatically set and
read cookies containing the session id.</p>
<p>
</p>
<h2><A NAME="data_caching">Data Caching</a></h2>
<p>Data caching is implemented with DeWitt Clinton's <code>Cache::Cache</code>
module.  For full understanding of this section you should read the
documentation for <code>Cache::Cache</code> as well as for relevant subclasses
(e.g. <code>Cache::FileCache</code>).</p>
<dl>
<dt><strong><A NAME="item_cache_files">Cache files</a></strong><br />
</dt>
<dd>
By default, <code>Cache::FileCache</code> is the subclass used for data caching,
although this may be overriden by the developer. <code>Cache::FileCache</code>
creates a separate subdirectory for every component that uses caching,
and one file some number of levels underneath that subdirectory for
each cached item.  The root of the cache tree is
<A HREF="Params.html#data_dir">data_dir</a>/<code>cache</code>. The name of the cache subdirectory for a component
is determined by the function <code>HTML::Mason::Utils::data_cache_namespace</code>.
</dd>
<p></p>
<dt><strong><A NAME="item_default_constructor_options">Default constructor options</a></strong><br />
</dt>
<dd>
Ordinarily, when <code>$m-&gt;cache</code> is called, Mason passes to the cache
constructor the <code>namespace</code>, and <code>cache_root</code> options, along with
any other options given in the <code>$m-&gt;cache</code> method.
</dd>
<dd>
<p>You may specify other default constructor options with the
<A HREF="Params.html#data_cache_defaults">data_cache_defaults</a> parameter. For example,</p>
</dd>
<dd>
<pre>
    PerlSetVar  MasonDataCacheDefaults  &quot;cache_class =&gt; SizeAwareFileCache&quot;
    PerlAddVar  MasonDataCacheDefaults  &quot;cache_depth =&gt; 2&quot;
    PerlAddVar  MasonDataCacheDefaults  &quot;default_expires_in =&gt; 1 hour&quot;</pre>
</dd>
<dd>
<p>Any options passed to individual <code>$m-&gt;cache</code> calls override these
defaults.</p>
</dd>
<p></p>
<dt><strong><A NAME="item_disabling_data_caching">Disabling data caching</a></strong><br />
</dt>
<dd>
If for some reason you want to disable data caching entirely, set the
default <code>cache_class</code> to ``NullCache''.  This subclass faithfully
implements the cache API but never stores data.
</dd>
<p></p></dl>
<p>
</p>
<hr />
<h1><A NAME="performance">PERFORMANCE</a></h1>
<p>This section explains Mason's various performance enhancements and how
to administer them.</p>
<p>
</p>
<h2><A NAME="code_cache">Code Cache</a></h2>
<p>When Mason loads a component, it places it in a memory cache.</p>
<p>The maximum size of the cache is specified with the
<A HREF="Params.html#code_cache_max_size">code_cache_max_size</a> parameter.  When the cache fills up, Mason
frees up space by discarding a number of components. The discard
algorithm is least frequently used (LFU), with a periodic decay to
gradually eliminate old frequency information. In a nutshell, the
components called most often in recent history should remain in the
cache.  Very large components (over 20% of the maximum cache size)
never get cached, on the theory that they would force out too many
other components.</p>
<p>Note that the ``size'' of a component in memory cannot literally be
measured.  It is estimated by the length of the source text plus some
overhead.  Your process growth will not match the code cache
size exactly.</p>
<p>You can prepopulate the cache with components that you know will be
accessed often; see <A HREF="#preloading_components">Preloading Components</a>.
Note that preloaded components possess no special status in the cache
and can be discarded like any others.</p>
<p>Naturally, a cache entry is invalidated if the corresponding component
source file changes.</p>
<p>To turn off code caching completely, set <A HREF="Params.html#code_cache_max_size">code_cache_max_size</a> to 0.</p>
<p>
</p>
<h2><A NAME="object_files">Object Files</a></h2>
<p>The in-memory code cache is only useful on a per-process basis.  Each
process must build and maintain its own cache. Shared memory caches
are conceivable in the future, but even those will not survive between
web server restarts.</p>
<p>As a secondary, longer-term cache mechanism, Mason stores a compiled
form of each component in an object file under <A HREF="Params.html#data_dir">data_dir</a>/obj. Any
server process can eval the object file and save time on parsing the
component source file.  The object file is recreated whenever the
source file changes.</p>
<p>Besides improving performance, object files can be useful for
debugging.  If you feel the need to see what your source has been
translated into, you can peek inside an object file to see exactly how
Mason converted a given component to a Perl object. This was crucial
for pre-1.10 Mason, in which error line numbers were based on the
object file rather than the source file.</p>
<p>If for some reason you don't want Mason to create object files, set
<A HREF="Params.html#use_object_files">use_object_files</a> to 0.</p>
<p>
</p>
<h2><A NAME="write_a_handler_subroutine">Write a handler subroutine</a></h2>
<p>Writing your own <code>handler()</code> subroutine which uses an ApacheHandler
object (or objects) created during server startup is slightly faster
(around 5% or so) than configuring mason via your <em>httpd.conf</em> file
and letting Mason create its own ApacheHandler objects internally.</p>
<p>
</p>
<h2><A NAME="static_source_mode">Static Source Mode</a></h2>
<p>As described above, Mason checks the timestamp of a component source
file every time that component is called. This can add up to a lot
of file stats.</p>
<p>If you have a live site with infrequent and well-controlled updates,
you may choose to use <A HREF="Params.html#static_source">static_source</a> mode. In this mode Mason will
not check source timestamps when it uses an in-memory cache or object
file.  The disadvantage is that you must remove object files and
restart the server whenever you change component source; however this
process can be easily automated.</p>
<p>
</p>
<h2><A NAME="preloading_components">Preloading Components</a></h2>
<p>You can tell Mason to preload a set of components in the parent
process, rather than loading them on demand, using the <A HREF="Params.html#preloads">preloads</a>
parameter.  Each child server will start with those components loaded
in the memory cache. The trade-offs are:</p>
<dl>
<dt><strong><A NAME="item_time">time</a></strong><br />
</dt>
<dd>
a small one-time startup cost, but children save time by not
having to load the components
</dd>
<p></p>
<dt><strong><A NAME="item_memory">memory</a></strong><br />
</dt>
<dd>
a fatter initial server, but the memory for preloaded components are
shared by all children.  This is similar to the advantage of using
modules only in the parent process.
</dd>
<p></p></dl>
<p>Try to preload components that are used frequently and do not change
often.  (If a preloaded component changes, all the children will have
to reload it from scratch.)</p>
<p>
</p>
<hr />
<h1><A NAME="error_reporting_and_exceptions">ERROR REPORTING AND EXCEPTIONS</a></h1>
<p>When an error occurs, Mason can respond by:</p>
<ul>
<li></li>
showing a detailed error message in the browser in HTML.
<p></p>
<li></li>
die'ing, which sends a 500 status to the browser and lets the error
message go to the error logs.
<p></p></ul>
<p>The first behavior is ideal for development, where you want immediate
feedback on the error.  The second behavior is usually desired for
production so that users are not exposed to messy error messages.  You
choose the behavior by setting <A HREF="Params.html#error_mode">error_mode</a> to ``output'' or ``fatal''
respectively.</p>
<p>Error formatting is controlled by the <A HREF="Params.html#error_format">error_format</a> parameter.  When
showing errors in the browser, Mason defaults to the ``html'' format.
When the <A HREF="Params.html#error_mode">error_mode</a> is set to ``fatal'', the default format is
``line'', which puts the entire error message on one line in a format
suitable for web server error logs.  Mason also offers other formats,
which are covered in the <a HREF="Request.html">Request class</a>
documentation.</p>
<p>Finally, you can use Apache's <code>ErrorDocument</code> directive to specify a
custom error handler for 500 errors.  In this case, you'd set the
<A HREF="Params.html#error_mode">error_mode</a> to ``fatal''.  The URL specified by the <code>ErrorDocument</code>
directive could point to a Mason component.</p>
<p>
</p>
<h2><A NAME="exceptions_under_the_hood">Exceptions Under the Hood</a></h2>
<p>The way that Mason really reports errors is through the use of
exception objects, which are implemented with the <code>Exception::Class</code>
module from CPAN, and some custom code in the
<a HREF="Exceptions.html">HTML::Mason::Exceptions</a> module.</p>
<p>If, during the execution of a component, execution stops because some
code calls <code>die()</code>, then Mason will catch this exception.  If the
exception being thrown is just a string, then it will be converted to
an <code>HTML::Mason::Exception</code> object.  If the exception being thrown is
an object with a <code>rethrow()</code> method, then this method will be called.
Otherwise, Mason simply leaves the exception untouched and calls
<code>die()</code> again.</p>
<p>
</p>
<h3><A NAME="calling_a_component_to_handle_er">Calling a Component to Handle Errors</a></h3>
<p>Returning to the topic of wrapper code that we covered earlier, what
if you wanted to handle all request errors by calling an error
handling component?  There is no way to do this without wrapper code.
Here's an example <code>handler()</code> subroutine that does this:</p>
<pre>
    sub handler {
        my ($r) = @_;</pre>
<pre>
        my $return = eval { $ah-&gt;handle_request($r) };</pre>
<pre>
        if ( my $err = $@ )
        {
            $r-&gt;pnotes( error =&gt; $err );
            $r-&gt;filename( $r-&gt;document_root . '/error/500.html' );</pre>
<pre>
            return $ah-&gt;handle_request($r);
        }</pre>
<pre>
        return $return;
    }</pre>
<p>First, we wrap our call to <code>$ah-&gt;handle_request()</code> in an
<code>eval{}</code> block.  If an error occurs, we store it in the request
object using the <code>$r-&gt;pnotes()</code> method.  Then we change the
filename property of the Apache request object to point to our
error-handling component and call the <code>$ah-&gt;handle_request()</code>
method again, passing it the altered request object.  We could have
put the exception in <code>$r-&gt;args</code>, but we want to leave this
untouched so that the error-handling component can see the original
arguments.</p>
<p>Here's what that component error-handling component might look like:</p>
<pre>
 &lt;html&gt;
 &lt;head&gt;
 &lt;title&gt;Error&lt;/title&gt;
 &lt;/head&gt;</pre>
<pre>
 &lt;body&gt;</pre>
<pre>
 &lt;p&gt;
 Looks like our application broke.  Whatever you did, don't do it again!
 &lt;/p&gt;</pre>
<pre>
 &lt;p&gt;
 If you have further questions, please feel free to contact us at &lt;a
 href=&quot;<a href="mailto:support@example.com">mailto:support@example.com</a>&quot;&gt;support@example.com&lt;/a&gt;.
 &lt;/p&gt;</pre>
<pre>
 &lt;p&gt;&lt;a href=&quot;/&quot;&gt;Click here&lt;/a&gt; to continue.&lt;/p&gt;</pre>
<pre>
 &lt;/body&gt;
 &lt;/html&gt;</pre>
<pre>
 &lt;%init&gt;
  my $error = $r-&gt;pnotes('error');</pre>
<pre>
  my $error_text = &quot;Page is &quot; . $r-&gt;parsed_uri-&gt;unparse . &quot;\n\n&quot;;</pre>
<pre>
  $error_text .= UNIVERSAL::can( $error, 'as_text' ) ? $error-&gt;as_text : $error;</pre>
<pre>
  $r-&gt;log_error($error_text);</pre>
<pre>
  my $mail =
      MIME::Lite-&gt;new
          ( From =&gt; 'error-handler@example.com',
            To   =&gt; 'rt@example.com',
            Subject =&gt; 'Application error',
            Data =&gt; $error_text,
          );</pre>
<pre>
  $r-&gt;register_cleanup( sub { $mail-&gt;send } );
 &lt;/%init&gt;</pre>
<pre>
 &lt;%flags&gt;
  inherit =&gt; undef
 &lt;/%flags&gt;</pre>
<p>This component does several things.  First of all, it logs the
complete error to the Apache error logs, along with the complete URL,
including query string, that was requested.  The <code>$r-&gt;parsed_uri()</code>
method that we use above is only available if the <code>Apache::URI</code>
module has been loaded.</p>
<p>The component also sends an email containing the error, in this case
to an RT installation, so that the error is logged in a bug tracking
system.  Finally, it displays a less technical error message to the
user.</p>
<p>For this to work properly, you must set <A HREF="Params.html#error_mode">error_mode</a> to ``fatal'', so
that Mason doesn't just display its own HTML error page.</p>
<p>
</p>
<hr />
<h1><A NAME="running_outside_of_mod_perl">RUNNING OUTSIDE OF MOD_PERL</a></h1>
<p>Although Mason is most commonly used in conjunction with mod_perl, the
APIs are flexible enough to use in any environment. Below we describe
the two most common alternative environments, CGI and standalone
scripts.</p>
<p>
</p>
<h2><A NAME="using_mason_from_a_cgi_script">Using Mason from a CGI Script</a></h2>
<p>The easiest way to use Mason via a CGI script is with the <a HREF="CGIHandler.html">CGIHandler module</a> module.</p>
<p>Here is a skeleton CGI script that calls a component and sends the
output to the browser.</p>
<pre>
    #!/usr/bin/perl
    use HTML::Mason::CGIHandler;</pre>
<pre>
    my $h = HTML::Mason::CGIHandler-&gt;new
     (
      data_dir  =&gt; '/home/jethro/code/mason_data',
     );</pre>
<pre>
    $h-&gt;handle_request;</pre>
<p>The relevant portions of the <em>httpd.conf</em> file look like:</p>
<pre>
    DocumentRoot /path/to/comp/root
    ScriptAlias /cgi-bin/ /path/to/cgi-bin/</pre>
<pre>
    Action html-mason /cgi-bin/mason_handler.cgi
    &lt;LocationMatch &quot;\.html$&quot;&gt;
      SetHandler html-mason
    &lt;/LocationMatch&gt;</pre>
<p>This simply causes Apache to call the mason_handler.cgi script every
time a URL ending in ``.html'' under the component root is requested.
This script uses the <a HREF="CGIHandler.html">CGIHandler class</a> to do
most of the heavy lifting.  See that class's documentation for more
details.</p>
<p>
</p>
<h2><A NAME="using_mason_from_a_standalone_sc">Using Mason from a Standalone Script</a></h2>
<p>Mason can be used as a pure text templating solution -- like
Text::Template and its brethren, but with more power (and of course
more complexity).</p>
<p>Here is a bare-bones script that calls a component file and sends
the result to standard output:</p>
<pre>
    #!/usr/bin/perl
    use HTML::Mason;
    use strict;</pre>
<pre>
    my $interp = HTML::Mason::Interp-&gt;new ();
    $interp-&gt;exec(&lt;relative path to file&gt;, &lt;args&gt;...);</pre>
<p>Because no component root was specified, the root is set to your
current working directory.  If you have a well defined and contained
component tree, you'll probably want to specify a component root.</p>
<p>Because no data directory was specified, object files will not be
created and data caching will not work in the default manner. If
performance is an issue, you will want to specify a data directory.</p>
<p>Here's a slightly fuller script that specifies a component root and
data directory, and captures the result in a variable rather than
sending to standard output:</p>
<pre>
    #!/usr/bin/perl
    use HTML::Mason;
    use strict;</pre>
<pre>
    my $outbuf;
    my $interp = HTML::Mason::Interp-&gt;new
        (comp_root  =&gt; '/path/to/comp_root',
         data_dir   =&gt; '/path/to/data_dir',
         out_method =&gt; \$outbuf
        );
    $interp-&gt;exec(&lt;component-path&gt;, &lt;args&gt;...);</pre>
<pre>
    # Do something with $outbuf</pre>
<p>
</p>
<hr />
<h1><A NAME="authors">AUTHORS</a></h1>
<p>Jonathan Swartz &lt;<a href="mailto:swartz@pobox.com">swartz@pobox.com</a>&gt;, Dave Rolsky &lt;<a href="mailto:autarch@urth.org">autarch@urth.org</a>&gt;, Ken Williams &lt;<a href="mailto:ken@mathforum.org">ken@mathforum.org</a>&gt;</p>
<p>
</p>
<hr />
<h1><A NAME="see_also">SEE ALSO</a></h1>
<p><a HREF="Mason.html">HTML::Mason</a>,
<a HREF="Interp.html">HTML::Mason::Interp</a>,
<a HREF="ApacheHandler.html">HTML::Mason::ApacheHandler</a>,
<a HREF="Lexer.html">HTML::Mason::Lexer</a>,
<a HREF="Compiler.html">HTML::Mason::Compiler</a></p>

</body>

</html>
