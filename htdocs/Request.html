<HTML>
<HEAD>
<TITLE>HTML::Mason::Request - Mason Request Class</TITLE>
<LINK REV="made" HREF="mailto:perl@packages.debian.org">
</HEAD>

<BODY>

<A NAME="__index__"></A>
<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#name">NAME</A></LI>
	<LI><A HREF="#synopsis">SYNOPSIS</A></LI>
	<LI><A HREF="#description">DESCRIPTION</A></LI>
	<LI><A HREF="#component paths">COMPONENT PATHS</A></LI>
	<LI><A HREF="#constructor parameters">CONSTRUCTOR PARAMETERS</A></LI>
	<LI><A HREF="#methods">METHODS</A></LI>
	<LI><A HREF="#apacheonly methods">APACHE-ONLY METHODS</A></LI>
	<LI><A HREF="#apache or cgionly method">APACHE- OR CGI-ONLY METHOD</A></LI>
	<LI><A HREF="#authors">AUTHORS</A></LI>
	<LI><A HREF="#see also">SEE ALSO</A></LI>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="name">NAME</A></H1>
<P>HTML::Mason::Request - Mason Request Class</P>
<P>
<HR>
<H1><A NAME="synopsis">SYNOPSIS</A></H1>
<PRE>
    $m-&gt;abort (...)
    $m-&gt;comp (...)
    etc.</PRE>
<P>
<HR>
<H1><A NAME="description">DESCRIPTION</A></H1>
<P>The Request API is your gateway to all Mason features not provided by
syntactic tags. Mason creates a new Request object for every web
request. Inside a component you access the current request object via
the global <CODE>$m</CODE>.  Outside of a component, you can use the class
method <A HREF="#item_instance"><CODE>instance</CODE></A>.</P>
<P>
<HR>
<H1><A NAME="component paths">COMPONENT PATHS</A></H1>
<P>The methods <A HREF="Request.html#comp">Request-&gt;comp</A>,
<A HREF="Request.html#comp_exists">Request-&gt;comp_exists</A>, and
<A HREF="Request.html#fetch_comp">Request-&gt;fetch_comp</A> take a
component path argument.  Component paths are like URL paths, and
always use a forward slash (/) as the separator, regardless of what
your operating system uses.</P>
<UL>
<LI>
If the path is absolute (starting with a '/'), then the component is
found relative to the component root.
<P></P>
<LI>
If the path is relative (no leading '/'), then the component is found
relative to the current component directory.
<P></P>
<LI>
If the path matches both a subcomponent and file-based component, the
subcomponent takes precedence.
<P></P></UL>
<P>
<HR>
<H1><A NAME="constructor parameters">CONSTRUCTOR PARAMETERS</A></H1>
<DL>
<DT><STRONG><A NAME="item_autoflush">autoflush</A></STRONG><BR>
<DD>
Indicates whether or not to delay sending output until all output has
been generated.
<P></P>
<DT><STRONG><A NAME="item_data_cache_defaults">data_cache_defaults</A></STRONG><BR>
<DD>
The default parameters used when $m-&gt;cache is called.
<P></P>
<DT><STRONG><A NAME="item_dhandler_name">dhandler_name</A></STRONG><BR>
<DD>
File name used for dhandlers. Default is ``dhandler''.
<P></P>
<DT><STRONG><A NAME="item_error_format">error_format</A></STRONG><BR>
<DD>
The format used to display errors.  The options are 'brief', 'text',
'line', and 'html'.  The default is 'text' except when running under
ApacheHandler, in which case the default is 'html'.
<P></P>
<DT><STRONG><A NAME="item_error_mode">error_mode</A></STRONG><BR>
<DD>
This can be either 'fatal' or 'output'.  If the mode is 'fatal',
errors generate an exception.  With 'output' mode, the error is sent
to the same output as normal component output.  The default is
'fatal', except when running under ApacheHandler or CGIHandler, in
which case the output is 'default'.
<P></P>
<DT><STRONG><A NAME="item_max_recurse">max_recurse</A></STRONG><BR>
<DD>
The maximum recursion depth for the component stack, for the request
stack, and for the inheritance stack. An error is signalled if the
maximum is exceeded.  Default is 32.
<P></P>
<DT><STRONG><A NAME="item_out_method">out_method</A></STRONG><BR>
<DD>
Indicates where to send output. If out_method is a reference to a
scalar, output is appended to the scalar.  If out_method is a
reference to a subroutine, the subroutine is called with each output
string. For example, to send output to a file called ``mason.out'':
<PRE>
    my $fh = new IO::File &quot;&gt;mason.out&quot;;
    ...
    out_method =&gt; sub { $fh-&gt;print($_[0]) }</PRE>
<P>By default, out_method prints to standard output.  When the
HTML::Mason::ApacheHandler module is used, the out method uses the <CODE>&lt;
$r-</CODE>print &gt;&gt; method to send output.</P>
<P></P></DL>
<P>
<HR>
<H1><A NAME="methods">METHODS</A></H1>
<a name="item_abort"><DL>
<DT><STRONG><A NAME="item_abort">abort ([return value])</A></STRONG><BR>
<DD>
Ends the current request, finishing the page without returning
through components. The optional argument specifies the return
value from <CODE>Interp::exec</CODE>; in a web environment, this ultimately
becomes the HTTP status code.
<P><A HREF="#item_abort"><CODE>abort</CODE></A> is implemented by throwing an HTML::Mason::Exception::Abort
object and can thus be caught by eval(). The <A HREF="#item_aborted"><CODE>aborted</CODE></A> method is a
shortcut for determining whether a caught error was generated by
<A HREF="#item_abort"><CODE>abort</CODE></A>.</P>
<a name="item_aborted"><P></P>
<DT><STRONG><A NAME="item_aborted">aborted ([$err])</A></STRONG><BR>
<DD>
Returns true or undef indicating whether the specified <CODE>$err</CODE>
was generated by <A HREF="#item_abort"><CODE>abort</CODE></A>. If no <CODE>$err</CODE> was passed, use <CODE>$@</CODE>.
<P>In this code, we catch and process fatal errors while letting <A HREF="#item_abort"><CODE>abort</CODE></A>
exceptions pass through:</P>
<PRE>
    eval { code_that_may_fail_or_abort() };
    if ($@) {
        die $@ if $m-&gt;aborted;</PRE>
<PRE>
        # handle fatal errors...</PRE>
<P><CODE>$@</CODE> can lose its value quickly, so if you are planning to call
$m-&gt;aborted more than a few lines after the eval, you should save $@
to a temporary variable.</P>
<a name="item_base_comp"><P></P>
<DT><STRONG><A NAME="item_base_comp">base_comp</A></STRONG><BR>
<DD>
Returns the current base component for method and attributes.
Generally set to the original page component; however, if you invoke
call_method on a component, <A HREF="#item_base_comp"><CODE>base_comp</CODE></A> is dynamically set to that
component until call_method exits. See <A HREF="Devel.html#objectoriented techniques">Object-Oriented Techniques in the <EM>Component Developer's Guide</EM></A> for examples of usage.
<a name="item_cache"><P></P>
<DT><STRONG><A NAME="item_cache">cache (cache_class=&gt;'...', [cache_options])</A></STRONG><BR>
<DD>
<A HREF="#item_cache"><CODE>$m-&gt;cache</CODE></A> returns a new cache object with a namespace specific
to this component.
<P><EM>cache_class</EM> specifies the class of cache object to create. It
defaults to Cache::FileCache in most cases, or Cache::MemoryCache if
the interpreter has no data directory, and must be a subclass of
Cache::Cache.  If <EM>cache_class</EM> does not contain a ``::'', the prefix
``Cache::'' is automatically prepended.</P>
<P><EM>cache_options</EM> may include any valid options to the <CODE>new()</CODE> method of
the cache class. e.g. for Cache::FileCache, valid options include
default_expires_in and cache_depth.</P>
<P>See the <A HREF="Devel.html#data caching">data caching in the <EM>Component Developer's Guide</EM></A> for examples and caching
strategies. See the Cache::Cache documentation for a complete list of
options and methods.</P>
<a name="item_cache_self"><P></P>
<DT><STRONG><A NAME="item_cache_self">cache_self (expires_in =&gt; '...', key =&gt; '...', [cache_options])</A></STRONG><BR>
<DD>
<A HREF="#item_cache_self"><CODE>$m-&gt;cache_self</CODE></A> caches the entire output and return result of a
component.
<P>It takes all of the options which can be passed to the cache method,
plus two additional options:</P>
<UL>
<LI>
<EM>expires_in</EM>: Indicates when the cache expires - it is passed as the
third argument to $cache-&gt;set.  See the Cache::Cache documentation
for details on what formats it accepts.
<P></P>
<LI>
<EM>key</EM>: An identifier used to uniquely identify the cache results - it
is passed as the first argument to $cache-&gt;get and
$cache-&gt;set.  A default key will be provided if none is passed.
<P></P></UL>
<P><A HREF="#item_cache_self"><CODE>cache_self</CODE></A> either returns undef, or a list containing the
return value of the component followed by '1'. You should return
immediately upon getting the latter result, as this indicates
that you are inside the second invocation of the component.</P>
<P>To cache the component's output:</P>
<PRE>
    &lt;%init&gt;
    return if $m-&gt;cache_self(expires_in =&gt; '3 hours'[, key =&gt; 'fookey']);
    ... &lt;rest of init&gt; ...
    &lt;/%init&gt;</PRE>
<P>To cache the component's scalar return value:</P>
<PRE>
    &lt;%init&gt;
    my ($result, $cached) = $m-&gt;cache_self(expires_in =&gt; '3 hours'[, key =&gt; 'fookey']);</PRE>
<PRE>
    return $result if $cached;
    ... &lt;rest of init&gt; ...
    &lt;/%init&gt;</PRE>
<P>To cache the component's list return value:</P>
<PRE>
    &lt;%init&gt;
    my (@retval) = $m-&gt;cache_self(expires_in =&gt; '3 hours'[, key =&gt; 'fookey']);</PRE>
<PRE>
    return @retval if pop @retval;
    ... &lt;rest of init&gt; ...
    &lt;/%init&gt;</PRE>
<P>We call <CODE>pop</CODE> on <CODE>@retval</CODE> to remove the mandatory '1' at the end of
the list.</P>
<a name="item_caller_args"><DT><STRONG><A NAME="item_caller_args">caller_args</A></STRONG><BR>
<DD>
Returns the arguments passed by the component at the specified stack
level. Use a positive argument to count from the current component and
a negative argument to count from the component at the bottom of the
stack. e.g.
<PRE>
    $m-&gt;caller_args(0)   # arguments passed to current component
    $m-&gt;caller_args(1)   # arguments passed to component that called us
    $m-&gt;caller_args(-1)  # arguments passed to first component executed</PRE>
<P>When called in scalar context, a hash reference is returned.  When
called in list context, a list of arguments (which may be assigned to
a hash) is returned.</P>
<a name="item_callers"><P></P>
<DT><STRONG><A NAME="item_callers">callers</A></STRONG><BR>
<DD>
With no arguments, returns the current component stack as a list of
component objects, starting with the current component and ending with
the top-level component. With one numeric argument, returns the
component object at that index in the list. Use a positive argument to
count from the current component and a negative argument to count from
the component at the bottom of the stack. e.g.
<PRE>
    my @comps = $m-&gt;callers   # all components
    $m-&gt;callers(0)            # current component
    $m-&gt;callers(1)            # component that called us
    $m-&gt;callers(-1)           # first component executed</PRE>
<a name="item_call_next"><P></P>
<DT><STRONG><A NAME="item_call_next">call_next ([args...])</A></STRONG><BR>
<DD>
Calls the next component in the content wrapping chain; usually called
from an autohandler. With no arguments, the original arguments are
passed to the component.  Any arguments specified here serve to
augment and override (in case of conflict) the original
arguments. Works like <A HREF="#item_comp"><CODE>$m-&gt;comp</CODE></A> in terms of return value and
scalar/list context.  See the <A HREF="Devel.html#autohandlers">autohandlers section in the <EM>Component Developer's Guide</EM></A> for
examples.
<a name="item_clear_buffer"><P></P>
<DT><STRONG><A NAME="item_clear_buffer">clear_buffer</A></STRONG><BR>
<DD>
Clears the Mason output buffer. Any output sent before this line is
discarded. Useful for handling error conditions that can only be
detected in the middle of a request.
<P>clear_buffer is, of course, thwarted by <A HREF="#item_flush_buffer"><CODE>flush_buffer</CODE></A>.</P>
<a name="item_comp"><P></P>
<DT><STRONG><A NAME="item_comp">comp (comp, args...)</A></STRONG><BR>
<DD>
Calls the component designated by <EM>comp</EM> with the specified
option/value pairs. <EM>comp</EM> may be a component path or a component
object.
<P>Components work exactly like Perl subroutines in terms of return
values and context. A component can return any type of value, which is
then returned from the <A HREF="#item_comp"><CODE>$m-&gt;comp</CODE></A> call.</P>
<P>The &lt;&amp; &amp;&gt; tag provides a convenient shortcut for <A HREF="#item_comp"><CODE>$m-&gt;comp</CODE></A>.</P>
<P>As of 1.10, component calls can accept an initial hash reference of
<EM>modifiers</EM>.  The only currently supported modifier is <CODE>store</CODE>, which
stores the component's output in a scalar reference. For example:</P>
<PRE>
  my $buf;
  my $return = $m-&gt;comp( { store =&gt; \$buf }, '/some/comp', type =&gt; 'big' );</PRE>
<P>This mostly duplicates the behavior of <EM>scomp</EM>, but can be useful in
rare cases where you need to capture both a component's output and
return value.</P>
<P>This modifier can be used with the &lt;&amp; &amp;&gt; tag as well, for example:</P>
<PRE>
  &lt;&amp; { store =&gt; \$buf }, '/some/comp', size =&gt; 'medium' &amp;&gt;</PRE>
<a name="item_comp_exists"><P></P>
<DT><STRONG><A NAME="item_comp_exists">comp_exists (comp_path)</A></STRONG><BR>
<DD>
Returns 1 if <EM>comp_path</EM> is the path of an existing component, 0
otherwise.  That path given may be relative, in which case the current
component's directory path will be prepended.
<a name="content"><P></P>
<DT><STRONG><A NAME="item_content">content</A></STRONG><BR>
<DD>
Evaluates the content (passed between &lt;&amp;| comp &amp;&gt; and &lt;/&amp;&gt; tags) of the 
current component, and returns the resulting text.
<P>Returns undef if there is no content.</P>
<a name="item_count"><P></P>
<DT><STRONG><A NAME="item_count">count</A></STRONG><BR>
<DD>
Returns the number of this request, which is unique for a given
request and interpreter.
<a name="item_current_comp"><P></P>
<DT><STRONG><A NAME="item_current_comp">current_comp</A></STRONG><BR>
<DD>
Returns the current component object.
<a name="item_decline"><P></P>
<DT><STRONG><A NAME="item_decline">decline</A></STRONG><BR>
<DD>
Used from a top-level component or dhandler, this method clears the
output buffer, aborts the current request and restarts with the next
applicable dhandler up the tree. If no dhandler is available, an error
occurs.  This method bears no relation to the Apache DECLINED status
except in name.
<a name="item_depth"><P></P>
<DT><STRONG><A NAME="item_depth">depth</A></STRONG><BR>
<DD>
Returns the current size of the component stack.  The lowest possible
value is 1, which indicates we are in the top-level component.
<a name="item_dhandler_arg"><P></P>
<DT><STRONG><A NAME="item_dhandler_arg">dhandler_arg</A></STRONG><BR>
<DD>
If the request has been handled by a dhandler, this method returns the
remainder of the URI or <CODE>Interp::exec</CODE> path when the dhandler directory is
removed. Otherwise returns undef.
<P><A HREF="#item_dhandler_arg"><CODE>dhandler_arg</CODE></A> may be called from any component in the request, not just
the dhandler.</P>
<a name="item_error_format"><P></P>
<DT><STRONG>error_format</STRONG><BR>
<DD>
Indicates how errors are formatted. The built-in choices are
<UL>
<LI>
<EM>brief</EM> - just the error message with no trace information
<P></P>
<LI>
<EM>text</EM> - a multi-line text format
<P></P>
<LI>
<EM>line</EM> - a single-line text format, with different pieces of information separated by tabs (useful for log files)
<P></P>
<LI>
<EM>html</EM> - a fancy html format
<P></P></UL>
<P>The default format within mod_perl and CGI environments is either <EM>line</EM> or
<EM>html</EM> depending on whether the error mode is <EM>fatal</EM> or <EM>output</EM>,
respectively. The default for standalone mode is <EM>text</EM>.</P>
<P>The formats correspond to HTML::Mason::Exception methods named
as_<EM>format</EM>. You can define your own format by creating an
appropriately named method; for example, to define an ``xml'' format,
create a method HTML::Mason::Exception::as_xml patterned after one of
the built-in methods.</P>
<a name="item_error_mode"><DT><STRONG>error_mode</STRONG><BR>
<DD>
Indicates how errors are returned to the caller.  The choices are
<EM>fatal</EM>, meaning die with the error, and <EM>output</EM>, meaning output
the error just like regular output.
<P>The default mode within mod_perl and CGI environments is <EM>output</EM>,
causing the error will be displayed in HTML form in the browser.
The default for standalone mode is <EM>fatal</EM>.</P>
<a name="item_exec"><P></P>
<DT><STRONG><A NAME="item_exec">exec (comp, args...)</A></STRONG><BR>
<DD>
Starts the request by executing the top-level component and
arguments. This is normally called for you on the main request, but
you can use it to execute subrequests.
<P>A request can only be executed once; e.g. it is an error to call this
recursively on the same request.</P>
<a name="item_fetch_comp"><P></P>
<DT><STRONG><A NAME="item_fetch_comp">fetch_comp (comp_path)</A></STRONG><BR>
<DD>
Given a <EM>comp_path</EM>, returns the corresponding component object or
undef if no such component exists.
<a name="item_fetch_next"><P></P>
<DT><STRONG><A NAME="item_fetch_next">fetch_next</A></STRONG><BR>
<DD>
Returns the next component in the content wrapping chain, or undef if
there is no next component. Usually called from an autohandler.  See
the <A HREF="Devel.html#autohandlers">autohandlers section in the <EM>Component Developer's Guide</EM></A> for usage and examples.
<a name="item_fetch_next_all"><P></P>
<DT><STRONG><A NAME="item_fetch_next_all">fetch_next_all</A></STRONG><BR>
<DD>
Returns a list of the remaining components in the content wrapping
chain. Usually called from an autohandler.  See the <A HREF="Devel.html#autohandlers">autohandlers section in the <EM>Component Developer's Guide</EM></A> for usage and examples.
<a name="item_file"><P></P>
<DT><STRONG><A NAME="item_file">file (filename)</A></STRONG><BR>
<DD>
Returns the contents of <EM>filename</EM> as a string. If <EM>filename</EM> is a
relative path, Mason prepends the current component directory.
<a name="item_flush_buffer"><P></P>
<DT><STRONG><A NAME="item_flush_buffer">flush_buffer</A></STRONG><BR>
<DD>
Flushes the Mason output buffer. Under mod_perl, also sends HTTP
headers if they haven't been sent and calls <CODE>$r-&gt;rflush</CODE> to flush
the Apache buffer. Flushing the initial bytes of output can make your
servers appear more responsive.
<P>Attempts to flush the buffers are ignored within the context of a call
to <A HREF="#item_scomp"><CODE>$m-&gt;scomp</CODE></A> or when output is being stored in a scalar
reference, as with the <CODE> { store =</CODE> \$out } &gt; component call
modifier.</P>
<P>Additionally, if a component has a <CODE>&lt;%filter&gt;</CODE> block, that
component is buffered until its entire output is generated.  This
means that inside that component and any components that it calls,
the buffer cannot be flushed.</P>
<a name="item_instance"><P></P>
<DT><STRONG><A NAME="item_instance">instance</A></STRONG><BR>
<DD>
This class method returns the <CODE>HTML::Mason:::Request</CODE> currently in
use.  If called when no Mason request is active it will return
<CODE>undef</CODE>.
<P>If called inside a subrequest, it returns the subrequest object.</P>
<a name="item_interp"><P></P>
<DT><STRONG><A NAME="item_interp">interp</A></STRONG><BR>
<DD>
Returns the Interp object associated with this request.
<a name="item_make_subrequest"><P></P>
<DT><STRONG><A NAME="item_make_subrequest">make_subrequest (parameters)</A></STRONG><BR>
<DD>
This method creates a new Request object which inherits its parent's
settable properties, such as <A HREF="#item_autoflush"><CODE>autoflush</CODE></A> and <A HREF="#item_out_method"><CODE>out_method</CODE></A>.  These
values may be overridden by passing parameters to this method.
<P>See the <A HREF="Devel.html#subrequests">Subrequests section in the <EM>Component Developer's Guide</EM></A> for more details about the
subrequest feature.</P>
<a name="item_out"><P></P>
<DT><STRONG><A NAME="item_out">out (string)</A></STRONG><BR>
<DD>
A synonym for <A HREF="#item_print"><CODE>$m-&gt;print</CODE></A>.
<a name="item_print"><P></P>
<DT><STRONG><A NAME="item_print">print (string)</A></STRONG><BR>
<DD>
Print the given <EM>string</EM>. Rarely needed, since normally all text is just
placed in the component body and output implicitly. <A HREF="#item_print"><CODE>$m-&gt;print</CODE></A> is useful
if you need to output something in the middle of a Perl block.
<P>In 1.1 and on, <A HREF="#item_print"><CODE>print</CODE></A> and <A HREF="#item_print"><CODE>$r-&gt;print</CODE></A> are remapped to <A HREF="#item_print"><CODE>$m-&gt;print</CODE></A>,
so they may be used interchangeably. Before 1.1, one should only use
<A HREF="#item_print"><CODE>$m-&gt;print</CODE></A>.</P>
<a name="item_scomp"><P></P>
<DT><STRONG><A NAME="item_scomp">scomp (comp, args...)</A></STRONG><BR>
<DD>
Like <A HREF="#item_comp"><CODE>$m-&gt;comp</CODE></A>, but returns the component output as a string
instead of printing it. (Think sprintf versus printf.) The
component's return value is discarded.
<a name="item_subexec"><P></P>
<DT><STRONG><A NAME="item_subexec">subexec (comp, args...)</A></STRONG><BR>
<DD>
This method creates a new subrequest with the specified top-level
component and arguments, and executes it. This is most often used
to perform an ``internal redirect'' to a new component such that
autohandlers and dhandlers take effect.
<a name="item_request_args"><P></P>
<DT><STRONG><A NAME="item_request_args">request_args</A></STRONG><BR>
<DD>
Returns the arguments originally passed to the top level component
(see <A HREF="Request.html#request_comp">Request-&gt;request_comp</A> for
definition).  When called in scalar context, a hash reference is
returned. When called in list context, a list of arguments (which may
be assigned to a hash) is returned.
<a name="item_request_comp"><P></P>
<DT><STRONG><A NAME="item_request_comp">request_comp</A></STRONG><BR>
<DD>
Returns the component originally called in the request. Without
autohandlers, this is the same as the first component executed.  With
autohandlers, this is the component at the end of the
<A HREF="#item_call_next"><CODE>$m-&gt;call_next</CODE></A> chain.
<P></P></DL>
<P>
<HR>
<H1><A NAME="apacheonly methods">APACHE-ONLY METHODS</A></H1>
<P>These additional methods are available when running Mason with mod_perl
and the ApacheHandler.</P>
<a name="item_ah"><DL>
<DT><STRONG><A NAME="item_ah">ah</A></STRONG><BR>
<DD>
Returns the ApacheHandler object associated with this request.
<a name="item_apache_req"><P></P>
<DT><STRONG><A NAME="item_apache_req">apache_req</A></STRONG><BR>
<DD>
Returns the Apache request object.  This is also available in the
global $r.
<a name="item_auto_send_headers"><P></P>
<DT><STRONG><A NAME="item_auto_send_headers">auto_send_headers</A></STRONG><BR>
<DD>
True or undef; default true.  Indicates whether Mason should
automatically send HTTP headers before sending content back to the
client. If you set to false, you should call $r-&gt;send_http_header
manually.
<P>See the <A HREF="Devel.html#sending http headers">Sending HTTP Headers section of the <EM>Component Developer's Guide</EM></A> for details about the
automatic header feature.</P>
<P></P></DL>
<P>
<HR>
<H1><A NAME="apache or cgionly method">APACHE- OR CGI-ONLY METHOD</A></H1>
<P>This method is available when Mason is running under either the
ApacheHandler or CGIHandler modules.</P>
<a name="item_cgi_object"><DL>
<DT><STRONG><A NAME="item_cgi_object">cgi_object</A></STRONG><BR>
<DD>
Returns the CGI object used to parse any CGI parameters submitted to
the component, assuming that you have not changed the default value of
the ApacheHandler <CODE>args_method</CODE> parameter.  If you are using the
'mod_perl' args method, then calling this method is a fatal error.
See the <A HREF="ApacheHandler.html">ApacheHandler</A> and
<A HREF="CGIHandler.html">CGIHandler</A> documentation for more details.
<a name="item_redirect"><P></P>
<DT><STRONG><A NAME="item_redirect">redirect ($url)</A></STRONG><BR>
<DD>
Given a url, this generates a proper HTTP redirect for that URL. It
uses $m-&gt;clear_buffer to clear out any previous output, and $m-&gt;abort
to abort the request with an appropriate status code.
<P></P></DL>
<P>
<HR>
<H1><A NAME="authors">AUTHORS</A></H1>
<P>Jonathan Swartz &lt;<A HREF="mailto:swartz@pobox.com">swartz@pobox.com</A>&gt;, Dave Rolsky &lt;<A HREF="mailto:autarch@urth.org">autarch@urth.org</A>&gt;, Ken Williams &lt;<A HREF="mailto:ken@mathforum.org">ken@mathforum.org</A>&gt;</P>
<P>
<HR>
<H1><A NAME="see also">SEE ALSO</A></H1>
<P><A HREF="Mason.html">HTML::Mason</A>,
<A HREF="Devel.html">HTML::Mason::Devel</A>,
<A HREF="Component.html">HTML::Mason::Component</A></P>

</BODY>

</HTML>
