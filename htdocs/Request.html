<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>HTML::Mason::Request - Mason Request Class</title>
<link rev="made" href="mailto:root@localhost" />
</head>

<body style="background-color: white">

<p><A NAME="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><A HREF="#name">NAME</a></li>
	<li><A HREF="#synopsis">SYNOPSIS</a></li>
	<li><A HREF="#description">DESCRIPTION</a></li>
	<li><A HREF="#component_paths">COMPONENT PATHS</a></li>
	<li><A HREF="#parameters_to_the_new___construc">PARAMETERS TO THE <code>new()</code> CONSTRUCTOR</a></li>
	<li><A HREF="#methods">METHODS</a></li>
	<li><A HREF="#apacheonly_methods">APACHE-ONLY METHODS</a></li>
	<li><A HREF="#cgionly_methods">CGI-ONLY METHODS</a></li>
	<li><A HREF="#apache_or_cgionly_methods">APACHE- OR CGI-ONLY METHODS</a></li>
	<li><A HREF="#authors">AUTHORS</a></li>
	<li><A HREF="#see_also">SEE ALSO</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<h1><A NAME="name">NAME</a></h1>
<p>HTML::Mason::Request - Mason Request Class</p>
<p>
</p>
<hr />
<h1><A NAME="synopsis">SYNOPSIS</a></h1>
<pre>
    $m-&gt;abort (...)
    $m-&gt;comp (...)
    etc.</pre>
<p>
</p>
<hr />
<h1><A NAME="description">DESCRIPTION</a></h1>
<p>The Request API is your gateway to all Mason features not provided by
syntactic tags. Mason creates a new Request object for every web
request. Inside a component you access the current request object via
the global <code>$m</code>.  Outside of a component, you can use the class
method <A HREF="#item_instance"><code>instance</code></a>.</p>
<p>
</p>
<hr />
<h1><A NAME="component_paths">COMPONENT PATHS</a></h1>
<p>The methods <A HREF="Request.html#item_comp">Request-&gt;comp</a>,
<A HREF="Request.html#item_comp_exists">Request-&gt;comp_exists</a>, and
<A HREF="Request.html#item_fetch_comp">Request-&gt;fetch_comp</a> take a
component path argument.  Component paths are like URL paths, and
always use a forward slash (/) as the separator, regardless of what
your operating system uses.</p>
<ul>
<li></li>
If the path is absolute (starting with a '/'), then the component is
found relative to the component root.
<p></p>
<li></li>
If the path is relative (no leading '/'), then the component is found
relative to the current component directory.
<p></p>
<li></li>
If the path matches both a subcomponent and file-based component, the
subcomponent takes precedence.
<p></p></ul>
<p>
</p>
<hr />
<h1><A NAME="parameters_to_the_new___construc">PARAMETERS TO THE <code>new()</code> CONSTRUCTOR</a></h1>
<dl>
<dt><strong><A NAME="item_autoflush">autoflush</a></strong><br />
</dt>
<dd>
True or false, default is false. Indicates whether to flush the output buffer
after every string is output. Turn on autoflush if you need to send partial
output to the client, for example in a progress meter.
</dd>
<p></p>
<dt><strong><A NAME="item_buffer_class">buffer_class</a></strong><br />
</dt>
<dd>
The class to use when creating buffers. Defaults to
<a HREF="Buffer.html">HTML::Mason::Buffer</a>.
</dd>
<p></p>
<dt><strong><A NAME="item_data_cache_api">data_cache_api</a></strong><br />
</dt>
<dd>
The <A HREF="#item_cache"><code>$m-&gt;cache</code></a> API to use. '1.1', the default, indicates the newer
API <A HREF="Request.html#item_cache">documented in this manual</a>.
'1.0' indicates the old API documented in 1.0x and earlier. This
compatibility layer is provided as a convenience for users upgrading
from older versions of Mason, but will not be supported indefinitely.
</dd>
<p></p>
<dt><strong><A NAME="item_data_cache_defaults">data_cache_defaults</a></strong><br />
</dt>
<dd>
A hash reference of default options to use for the <A HREF="#item_cache"><code>$m-&gt;cache</code></a>
command. For example, to use the <code>MemoryCache</code> implementation
by default,
</dd>
<dd>
<pre>
    data_cache_defaults =&gt; {cache_class =&gt; 'MemoryCache'}</pre>
</dd>
<dd>
<p>These settings are overriden by options given to particular
<A HREF="#item_cache"><code>$m-&gt;cache</code></a> calls.</p>
</dd>
<p></p>
<dt><strong><A NAME="item_dhandler_name">dhandler_name</a></strong><br />
</dt>
<dd>
File name used for <A HREF="Devel.html#dhandlers">dhandlers</a>. Default
is ``dhandler''.  If this is set to an empty string (``'') then dhandlers
are turned off entirely.
</dd>
<p></p>
<dt><strong><A NAME="item_error_format">error_format</a></strong><br />
</dt>
<dd>
Indicates how errors are formatted. The built-in choices are
</dd>
<ul>
<li></li>
<em>brief</em> - just the error message with no trace information
<p></p>
<li></li>
<em>text</em> - a multi-line text format
<p></p>
<li></li>
<em>line</em> - a single-line text format, with different pieces of information separated by tabs (useful for log files)
<p></p>
<li></li>
<em>html</em> - a fancy html format
<p></p></ul>
<p>The default format under <a HREF="ApacheHandler.html">Apache</a> and
<a HREF="CGIHandler.html">CGI</a> is either <em>line</em> or <em>html</em> depending
on whether the error mode is <em>fatal</em> or <em>output</em>, respectively. The
default for standalone mode is <em>text</em>.</p>
<p>The formats correspond to <code>HTML::Mason::Exception</code> methods named
as_<em>format</em>. You can define your own format by creating an
appropriately named method; for example, to define an ``xml'' format,
create a method <code>HTML::Mason::Exception::as_xml</code> patterned after one of
the built-in methods.</p>
<dt><strong><A NAME="item_error_mode">error_mode</a></strong><br />
</dt>
<dd>
Indicates how errors are returned to the caller.  The choices are
<em>fatal</em>, meaning die with the error, and <em>output</em>, meaning output
the error just like regular output.
</dd>
<dd>
<p>The default under <a HREF="ApacheHandler.html">Apache</a> and
<a HREF="CGIHandler.html">CGI</a> is <em>output</em>, causing the error to be
displayed in the browser.  The default for standalone mode is
<em>fatal</em>.</p>
</dd>
<p></p>
<dt><strong><A NAME="item_max_recurse">max_recurse</a></strong><br />
</dt>
<dd>
The maximum recursion depth for the component stack, for the request
stack, and for the inheritance stack. An error is signalled if the
maximum is exceeded.  Default is 32.
</dd>
<p></p>
<dt><strong><A NAME="item_out_method">out_method</a></strong><br />
</dt>
<dd>
Indicates where to send output. If out_method is a reference to a
scalar, output is appended to the scalar.  If out_method is a
reference to a subroutine, the subroutine is called with each output
string. For example, to send output to a file called ``mason.out'':
</dd>
<dd>
<pre>
    my $fh = new IO::File &quot;&gt;mason.out&quot;;
    ...
    out_method =&gt; sub { $fh-&gt;print($_[0]) }</pre>
</dd>
<dd>
<p>By default, out_method prints to standard output. Under
<a HREF="ApacheHandler.html">Apache</a>, standard output is
redirected to <A HREF="#item_print"><code>$r-&gt;print</code></a>.</p>
</dd>
<p></p></dl>
<p>
</p>
<hr />
<h1><A NAME="methods">METHODS</a></h1>
<A NAME="item_abort"></a><dl>
<dt><strong><A NAME="item_abort">abort ([return value])</a></strong><br />
</dt>
<dd>
Ends the current request, finishing the page without returning
through components. The optional argument specifies the return
value from <code>Interp::exec</code>; in a web environment, this ultimately
becomes the HTTP status code.
</dd>
<dd>
<p><A HREF="#item_abort"><code>abort</code></a> is implemented by throwing an HTML::Mason::Exception::Abort
object and can thus be caught by eval(). The <A HREF="#item_aborted"><code>aborted</code></a> method is a
shortcut for determining whether a caught error was generated by
<A HREF="#item_abort"><code>abort</code></a>.</p>
</dd>
<dd>
<p>If <A HREF="#item_abort"><code>abort</code></a> is called from a component that has a <code>&lt;%filter&gt;</code>,
than any output generated up to that point is filtered, <em>unless</em>
<A HREF="#item_abort"><code>abort</code></a> is called from a <code>&lt;%shared&gt;</code> block.</p>
</dd>
<A NAME="item_aborted"></a><p></p>
<dt><strong><A NAME="item_aborted">aborted ([$err])</a></strong><br />
</dt>
<dd>
Returns true or undef indicating whether the specified <code>$err</code>
was generated by <A HREF="#item_abort"><code>abort</code></a>. If no <code>$err</code> was passed, uses <code>$@</code>.
</dd>
<dd>
<p>In this code, we catch and process fatal errors while letting <A HREF="#item_abort"><code>abort</code></a>
exceptions pass through:</p>
</dd>
<dd>
<pre>
    eval { code_that_may_fail_or_abort() };
    if ($@) {
        die $@ if $m-&gt;aborted;</pre>
</dd>
<dd>
<pre>
        # handle fatal errors...</pre>
</dd>
<dd>
<p><code>$@</code> can lose its value quickly, so if you are planning to call
$m-&gt;aborted more than a few lines after the eval, you should save $@
to a temporary variable.</p>
</dd>
<A NAME="item_base_comp"></a><p></p>
<dt><strong><A NAME="item_base_comp">base_comp</a></strong><br />
</dt>
<dd>
Returns the current base component for method and attributes.
Initially, the base component is the same as the requested component
(returned by <A HREF="#item_request_comp"><code>$m-&gt;request_comp</code></a>.  However, whenever a component
call is made, the base component changes to the called component,
unless the component call was made uses a component object for its
first argument, or the call starts with SELF:, PARENT:, or REQUEST.
</dd>
<A NAME="item_cache"></a><p></p>
<dt><strong><A NAME="item_cache">cache (cache_class=&gt;'...', [cache_options])</a></strong><br />
</dt>
<dd>
<A HREF="#item_cache"><code>$m-&gt;cache</code></a> returns a new <a HREF="Cache/BaseCache.html">cache object</a> with a namespace specific to
this component.
</dd>
<dd>
<p><em>cache_class</em> specifies the class of cache object to create. It
defaults to <code>FileCache</code> in most cases, or <code>MemoryCache</code> if the
interpreter has no data directory, and must be a backend subclass of
<code>Cache::Cache</code>. The prefix ``Cache::'' need not be included.  See the
<code>Cache::Cache</code> package for a full list of backend subclasses.
</p>
</dd>
<dd>
<pre>

I&lt;cache_options&gt; may include any valid options to the new() method of
the cache class. e.g. for C&lt;FileCache&gt;, valid options include
default_expires_in and cache_depth.</pre>
</dd>
<dd>
<p>See the <A HREF="Devel.html#data_caching">data caching</a> section of the developer's manual for a caching tutorial and examples. See the
<a HREF="Cache/BaseCache.html">HTML::Mason::Cache::BaseCache</a>
documentation for a method reference.</p>
</dd>
<dd>
<p>Note: users upgrading from 1.0x and earlier can continue to use the
old <A HREF="#item_cache"><code>$m-&gt;cache</code></a> API by setting <A HREF="Params.html#data_cache_api">data_cache_api</a> to '1.0'.  This
support will be removed at a later date.</p>
</dd>
<A NAME="item_cache_self"></a><p></p>
<dt><strong><A NAME="item_cache_self">cache_self ([expires_in =&gt; '...'], [key =&gt; '...'], [get_options], [cache_options])</a></strong><br />
</dt>
<dd>
<A HREF="#item_cache_self"><code>$m-&gt;cache_self</code></a> caches the entire output and return result of a
component.
</dd>
<dd>
<p><A HREF="#item_cache_self"><code>cache_self</code></a> either returns undef, or a list containing the
return value of the component followed by '1'. You should return
immediately upon getting the latter result, as this indicates
that you are inside the second invocation of the component.</p>
</dd>
<dd>
<p><A HREF="#item_cache_self"><code>cache_self</code></a> takes any of parameters to <A HREF="#item_cache"><code>$m-&gt;cache</code></a>
(e.g. <em>cache_depth</em>), any of the optional parameters to
<code>$cache-&gt;get</code> (<em>expire_if</em>, <em>busy_lock</em>), and two additional
options:</p>
</dd>
<ul>
<li></li>
<em>expire_in</em> or <em>expires_in</em>: Indicates when the cache expires - it
is passed as the third argument to <code>$cache-&gt;set</code>. e.g. '10 sec',
'5 min', '2 hours'.
<p></p>
<li></li>
<em>key</em>: An identifier used to uniquely identify the cache results - it
is passed as the first argument to <code>$cache-&gt;get</code> and
<code>$cache-&gt;set</code>.  The default key is '__mason_cache_self__'.
<p></p></ul>
<p>To cache the component's output:</p>
<pre>
    &lt;%init&gt;
    return if $m-&gt;cache_self(expire_in =&gt; '10 sec'[, key =&gt; 'fookey']);
    ... &lt;rest of init&gt; ...
    &lt;/%init&gt;</pre>
<p>To cache the component's scalar return value:</p>
<pre>
    &lt;%init&gt;
    my ($result, $cached) = $m-&gt;cache_self(expire_in =&gt; '5 min'[, key =&gt; 'fookey']);</pre>
<pre>
    return $result if $cached;
    ... &lt;rest of init&gt; ...
    &lt;/%init&gt;</pre>
<p>To cache the component's list return value:</p>
<pre>
    &lt;%init&gt;
    my (@retval) = $m-&gt;cache_self(expire_in =&gt; '3 hours'[, key =&gt; 'fookey']);</pre>
<pre>
    return @retval if pop @retval;
    ... &lt;rest of init&gt; ...
    &lt;/%init&gt;</pre>
<p>We call <code>pop</code> on <code>@retval</code> to remove the mandatory '1' at the end of
the list.</p>
<p>If a component has a <code>&lt;%filter&gt;</code> block, then the <em>filtered</em>
output is cached.</p>
<p>Note: users upgrading from 1.0x and earlier can continue to use the
old <A HREF="#item_cache_self"><code>$m-&gt;cache_self</code></a> API by setting <A HREF="Params.html#data_cache_api">data_cache_api</a> to '1.0'.
This support will be removed at a later date.</p>
<p>See the the <A HREF="Devel.html#data_caching">DATA CACHING</a> section of the developer's manual section for more details on how to
exercise finer control over caching.</p>
<A NAME="item_caller_args"></a><dt><strong><A NAME="item_caller_args">caller_args</a></strong><br />
</dt>
<dd>
Returns the arguments passed by the component at the specified stack
level. Use a positive argument to count from the current component and
a negative argument to count from the component at the bottom of the
stack. e.g.
</dd>
<dd>
<pre>
    $m-&gt;caller_args(0)   # arguments passed to current component
    $m-&gt;caller_args(1)   # arguments passed to component that called us
    $m-&gt;caller_args(-1)  # arguments passed to first component executed</pre>
</dd>
<dd>
<p>When called in scalar context, a hash reference is returned.  When
called in list context, a list of arguments (which may be assigned to
a hash) is returned.  Returns undef or an empty list, depending on
context, if the specified stack level does not exist.</p>
</dd>
<A NAME="item_callers"></a><p></p>
<dt><strong><A NAME="item_callers">callers</a></strong><br />
</dt>
<dd>
With no arguments, returns the current component stack as a list of
component objects, starting with the current component and ending with
the top-level component. With one numeric argument, returns the
component object at that index in the list. Use a positive argument to
count from the current component and a negative argument to count from
the component at the bottom of the stack. e.g.
</dd>
<dd>
<pre>
    my @comps = $m-&gt;callers   # all components
    $m-&gt;callers(0)            # current component
    $m-&gt;callers(1)            # component that called us
    $m-&gt;callers(-1)           # first component executed</pre>
</dd>
<dd>
<p>Returns undef or an empty list, depending on context, if the specified
stack level does not exist.</p>
</dd>
<A NAME="item_caller"></a><p></p>
<dt><strong><A NAME="item_caller">caller</a></strong><br />
</dt>
<dd>
A synonym for <A HREF="#item_callers"><code>$m-&gt;callers(1)</code></a>, i.e. the component that called the
currently executing component.
</dd>
<A NAME="item_call_next"></a><p></p>
<dt><strong><A NAME="item_call_next">call_next ([args...])</a></strong><br />
</dt>
<dd>
Calls the next component in the content wrapping chain; usually called
from an autohandler. With no arguments, the original arguments are
passed to the component.  Any arguments specified here serve to
augment and override (in case of conflict) the original
arguments. Works like <A HREF="#item_comp"><code>$m-&gt;comp</code></a> in terms of return value and
scalar/list context.  See the <A HREF="Devel.html#autohandlers">autohandlers</a> section of the developer's manual for examples.
</dd>
<A NAME="item_call_self"></a><p></p>
<dt><strong><A NAME="item_call_self">call_self (output, return)</a></strong><br />
</dt>
<dd>
This method allows a component to call itself so that it can filter
both its output and return values.  It is fairly advanced; for most
purposes the <code>&lt;%filter&gt;</code> tag will be sufficient and simpler.
</dd>
<dd>
<p><A HREF="#item_call_self"><code>$m-&gt;call_self</code></a> takes two arguments.  The first is a scalar
reference and will be populated with the component output.  The second
is either a scalar or list reference and will be populated with the
component return value; the type of reference determines whether the
component will be called in scalar or list context.  Both of these
arguments are optional; you may pass undef for either of them.</p>
</dd>
<dd>
<p><A HREF="#item_call_self"><code>$m-&gt;call_self</code></a> acts like a <code>fork()</code> in the sense that it will
return twice with different values.  When it returns 0, you allow
control to pass through to the rest of your component.  When it
returns 1, that means the component has finished and you can begin
filtering the output and/or return value. (Don't worry, it doesn't
really do a fork! See next section for explanation.)</p>
</dd>
<dd>
<p>The following examples would generally appear at the top of a <code>&lt;
&lt;%init</code> &gt;&gt; section.  Here is a no-op <A HREF="#item_call_self"><code>$m-&gt;call_self</code></a> that leaves
the output and return value untouched:</p>
</dd>
<dd>
<pre>
    &lt;%init&gt;
    my ($output, $retval);
    if ($m-&gt;call_self(\$output, \$retval)) {
        $m-&gt;print($output);
        return $retval;
    }
    ...</pre>
</dd>
<dd>
<p>Here is a simple output filter that makes the output all uppercase.
Note that we ignore both the original and the final return value.</p>
</dd>
<dd>
<pre>
    &lt;%init&gt;
    my $output;
    if ($m-&gt;call_self(\$output, undef)) {
        $m-&gt;print(uc $output);
        return;
    }
    ...</pre>
</dd>
<dd>
<p>Here is a piece of code that traps all errors occuring anywhere in the
component or its children, e.g. for the purpose of handling
application-specific exceptions. This is difficult to do with a manual
<code>eval</code> because it would have to span multiple code sections and the
main component body.</p>
</dd>
<dd>
<pre>
    &lt;%init&gt;
    # Run this component with an eval around it
    my $in_parent = eval { $m-&gt;call_self() };
    if ($@) {
        # check $@ and do something with it
    }
    return if $in_parent;
    ...</pre>
</dd>
<A NAME="item_clear_buffer"></a><p></p>
<dt><strong><A NAME="item_clear_buffer">clear_buffer</a></strong><br />
</dt>
<dd>
Clears the Mason output buffer. Any output sent before this line is
discarded. Useful for handling error conditions that can only be
detected in the middle of a request.
</dd>
<dd>
<p>clear_buffer is, of course, thwarted by <A HREF="#item_flush_buffer"><code>flush_buffer</code></a>.</p>
</dd>
<A NAME="item_comp"></a><p></p>
<dt><strong><A NAME="item_comp">comp (comp, args...)</a></strong><br />
</dt>
<dd>
Calls the component designated by <em>comp</em> with the specified
option/value pairs. <em>comp</em> may be a component path or a component
object.
</dd>
<dd>
<p>Components work exactly like Perl subroutines in terms of return
values and context. A component can return any type of value, which is
then returned from the <A HREF="#item_comp"><code>$m-&gt;comp</code></a> call.</p>
</dd>
<dd>
<p>The &lt;&amp; &amp;&gt; tag provides a convenient shortcut for <A HREF="#item_comp"><code>$m-&gt;comp</code></a>.</p>
</dd>
<dd>
<p>As of 1.10, component calls can accept an initial hash reference of
<em>modifiers</em>.  The only currently supported modifier is <code>store</code>, which
stores the component's output in a scalar reference. For example:</p>
</dd>
<dd>
<pre>
  my $buf;
  my $return = $m-&gt;comp( { store =&gt; \$buf }, '/some/comp', type =&gt; 'big' );</pre>
</dd>
<dd>
<p>This mostly duplicates the behavior of <em>scomp</em>, but can be useful in
rare cases where you need to capture both a component's output and
return value.</p>
</dd>
<dd>
<p>This modifier can be used with the &lt;&amp; &amp;&gt; tag as well, for example:</p>
</dd>
<dd>
<pre>
  &lt;&amp; { store =&gt; \$buf }, '/some/comp', size =&gt; 'medium' &amp;&gt;</pre>
</dd>
<A NAME="item_comp_exists"></a><p></p>
<dt><strong><A NAME="item_comp_exists">comp_exists (comp_path)</a></strong><br />
</dt>
<dd>
Returns 1 if <em>comp_path</em> is the path of an existing component, 0
otherwise.  That path given may be relative, in which case the current
component's directory path will be prepended.
</dd>
<A NAME="content"></a><p></p>
<dt><strong><A NAME="item_content">content</a></strong><br />
</dt>
<dd>
Evaluates the content (passed between &lt;&amp;| comp &amp;&gt; and &lt;/&amp;&gt; tags) of the 
current component, and returns the resulting text.
</dd>
<dd>
<p>Returns undef if there is no content.</p>
</dd>
<A NAME="has_content"></a><p></p>
<dt><strong><A NAME="item_has_content">has_content</a></strong><br />
</dt>
<dd>
Returns true if the component was called with content (i.e. with &lt;&amp;|
comp &amp;&gt; and &lt;/&amp;&gt; tags instead of a single &lt;&amp; comp &amp;&gt; tag). This is
generally better than checking the defined'ness of <A HREF="#item_content"><code>$m-&gt;content</code></a>
because it will not try to evaluate the content.
</dd>
<A NAME="item_count"></a><p></p>
<dt><strong><A NAME="item_count">count</a></strong><br />
</dt>
<dd>
Returns the number of this request, which is unique for a given
request and interpreter.
</dd>
<A NAME="item_current_comp"></a><p></p>
<dt><strong><A NAME="item_current_comp">current_comp</a></strong><br />
</dt>
<dd>
Returns the current component object.
</dd>
<A NAME="item_decline"></a><p></p>
<dt><strong><A NAME="item_decline">decline</a></strong><br />
</dt>
<dd>
Used from a top-level component or dhandler, this method clears the
output buffer, aborts the current request and restarts with the next
applicable dhandler up the tree. If no dhandler is available, an error
occurs.  This method bears no relation to the Apache DECLINED status
except in name.
</dd>
<A NAME="item_declined"></a><p></p>
<dt><strong><A NAME="item_declined">declined ([$err])</a></strong><br />
</dt>
<dd>
Returns true or undef indicating whether the specified <code>$err</code> was
generated by <A HREF="#item_decline"><code>decline</code></a>. If no <code>$err</code> was passed, uses <code>$@</code>.
</dd>
<A NAME="item_depth"></a><p></p>
<dt><strong><A NAME="item_depth">depth</a></strong><br />
</dt>
<dd>
Returns the current size of the component stack.  The lowest possible
value is 1, which indicates we are in the top-level component.
</dd>
<A NAME="item_dhandler_arg"></a><p></p>
<dt><strong><A NAME="item_dhandler_arg">dhandler_arg</a></strong><br />
</dt>
<dd>
If the request has been handled by a dhandler, this method returns the
remainder of the URI or <code>Interp::exec</code> path when the dhandler directory is
removed. Otherwise returns undef.
</dd>
<dd>
<p><A HREF="#item_dhandler_arg"><code>dhandler_arg</code></a> may be called from any component in the request, not just
the dhandler.</p>
</dd>
<A NAME="item_exec"></a><p></p>
<dt><strong><A NAME="item_exec">exec (comp, args...)</a></strong><br />
</dt>
<dd>
Starts the request by executing the top-level component and
arguments. This is normally called for you on the main request, but
you can use it to execute subrequests.
</dd>
<dd>
<p>A request can only be executed once; e.g. it is an error to call this
recursively on the same request.</p>
</dd>
<A NAME="item_fetch_comp"></a><p></p>
<dt><strong><A NAME="item_fetch_comp">fetch_comp (comp_path)</a></strong><br />
</dt>
<dd>
Given a <em>comp_path</em>, returns the corresponding component object or
undef if no such component exists.
</dd>
<A NAME="item_fetch_next"></a><p></p>
<dt><strong><A NAME="item_fetch_next">fetch_next</a></strong><br />
</dt>
<dd>
Returns the next component in the content wrapping chain, or undef if
there is no next component. Usually called from an autohandler.  See
the <A HREF="Devel.html#autohandlers">autohandlers</a> section of the developer's manual for usage and examples.
</dd>
<A NAME="item_fetch_next_all"></a><p></p>
<dt><strong><A NAME="item_fetch_next_all">fetch_next_all</a></strong><br />
</dt>
<dd>
Returns a list of the remaining components in the content wrapping
chain. Usually called from an autohandler.  See the <A HREF="Devel.html#autohandlers">autohandlers</a> section of the developer's manual
for usage and examples.
</dd>
<A NAME="item_file"></a><p></p>
<dt><strong><A NAME="item_file">file (filename)</a></strong><br />
</dt>
<dd>
Returns the contents of <em>filename</em> as a string. If <em>filename</em> is a
relative path, Mason prepends the current component directory.
</dd>
<A NAME="item_flush_buffer"></a><p></p>
<dt><strong><A NAME="item_flush_buffer">flush_buffer</a></strong><br />
</dt>
<dd>
Flushes the Mason output buffer. Under mod_perl, also sends HTTP
headers if they haven't been sent and calls <code>$r-&gt;rflush</code> to flush
the Apache buffer. Flushing the initial bytes of output can make your
servers appear more responsive.
</dd>
<dd>
<p>Attempts to flush the buffers are ignored within the context of a call
to <A HREF="#item_scomp"><code>$m-&gt;scomp</code></a> or when output is being stored in a scalar
reference, as with the <code> { store =&gt; \$out } </code> component call
modifier.</p>
</dd>
<dd>
<p>Additionally, if a component has a <code>&lt;%filter&gt;</code> block, that
component is buffered until its entire output is generated.  This
means that inside that component and any components that it calls,
the buffer cannot be flushed.</p>
</dd>
<A NAME="item_instance"></a><p></p>
<dt><strong><A NAME="item_instance">instance</a></strong><br />
</dt>
<dd>
This class method returns the <code>HTML::Mason::Request</code> currently in
use.  If called when no Mason request is active it will return
<code>undef</code>.
</dd>
<dd>
<p>If called inside a subrequest, it returns the subrequest object.</p>
</dd>
<A NAME="item_interp"></a><p></p>
<dt><strong><A NAME="item_interp">interp</a></strong><br />
</dt>
<dd>
Returns the Interp object associated with this request.
</dd>
<A NAME="item_make_subrequest"></a><p></p>
<dt><strong><A NAME="item_make_subrequest">make_subrequest (comp =&gt; path, args =&gt; arrayref, other parameters)</a></strong><br />
</dt>
<dd>
This method creates a new Request object which inherits its parent's
settable properties, such as <A HREF="Params.html#autoflush">autoflush</a> and <A HREF="Params.html#out_method">out_method</a>.  These
values may be overridden by passing parameters to this method.
</dd>
<dd>
<p>The <A HREF="#item_comp"><code>comp</code></a> parameter is required, while all other parameters are
optional.  It may be specified as an absolute path or as a path
relative to the current component.</p>
</dd>
<dd>
<p>See the <A HREF="Devel.html#subrequests">subrequests</a> section of the developer's manual for more information about subrequests.</p>
</dd>
<A NAME="notes"></a><p></p>
<dt><strong><A NAME="item_notes">notes (key, value)</a></strong><br />
</dt>
<dd>
The <A HREF="#item_notes"><code>notes()</code></a> method provides a place to store application data,
giving developers a way to share data among multiple components.  Any
data stored here persists for the duration of the request, i.e. the
same lifetime as the Request object.
</dd>
<dd>
<p>Conceptually, <A HREF="#item_notes"><code>notes()</code></a> contains a hash of key-value pairs.
<A HREF="#item_notes"><code>notes($key, $value)</code></a> stores a new entry in this hash.
<A HREF="#item_notes"><code>notes($key)</code></a> returns a previously stored value.  <A HREF="#item_notes"><code>notes()</code></a> without
any arguments returns a reference to the entire hash of key-value
pairs.</p>
</dd>
<dd>
<p><A HREF="#item_notes"><code>notes()</code></a> is similar to the mod_perl method <code>$r-&gt;pnotes()</code>.  The
main differences are that this <A HREF="#item_notes"><code>notes()</code></a> can be used in a
non-mod_perl environment, and that its lifetime is tied to the
<em>Mason</em> request object, not the <em>Apache</em> request object.  In
particular, a Mason subrequest has its own <A HREF="#item_notes"><code>notes()</code></a> structure, but
would access the same <code>$r-&gt;pnotes()</code> structure.</p>
</dd>
<A NAME="item_out"></a><p></p>
<dt><strong><A NAME="item_out">out (string)</a></strong><br />
</dt>
<dd>
A synonym for <A HREF="#item_print"><code>$m-&gt;print</code></a>.
</dd>
<A NAME="item_print"></a><p></p>
<dt><strong><A NAME="item_print">print (string)</a></strong><br />
</dt>
<dd>
Print the given <em>string</em>. Rarely needed, since normally all text is just
placed in the component body and output implicitly. <A HREF="#item_print"><code>$m-&gt;print</code></a> is useful
if you need to output something in the middle of a Perl block.
</dd>
<dd>
<p>In 1.1 and on, <A HREF="#item_print"><code>print</code></a> and <A HREF="#item_print"><code>$r-&gt;print</code></a> are remapped to <A HREF="#item_print"><code>$m-&gt;print</code></a>,
so they may be used interchangeably. Before 1.1, one should only use
<A HREF="#item_print"><code>$m-&gt;print</code></a>.</p>
</dd>
<A NAME="item_request_args"></a><p></p>
<dt><strong><A NAME="item_request_args">request_args</a></strong><br />
</dt>
<dd>
Returns the arguments originally passed to the top level component
(see <A HREF="Request.html#item_request_comp">request_comp</a> for
definition).  When called in scalar context, a hash reference is
returned. When called in list context, a list of arguments (which may
be assigned to a hash) is returned.
</dd>
<A NAME="item_request_comp"></a><p></p>
<dt><strong><A NAME="item_request_comp">request_comp</a></strong><br />
</dt>
<dd>
Returns the component originally called in the request. Without
autohandlers, this is the same as the first component executed.  With
autohandlers, this is the component at the end of the
<A HREF="#item_call_next"><code>$m-&gt;call_next</code></a> chain.
</dd>
<A NAME="item_scomp"></a><p></p>
<dt><strong><A NAME="item_scomp">scomp (comp, args...)</a></strong><br />
</dt>
<dd>
Like <A HREF="Request.html#item_comp">comp</a>, but returns the component output as a string
instead of printing it. (Think sprintf versus printf.) The
component's return value is discarded.
</dd>
<A NAME="item_subexec"></a><p></p>
<dt><strong><A NAME="item_subexec">subexec (comp, args...)</a></strong><br />
</dt>
<dd>
This method creates a new subrequest with the specified top-level
component and arguments, and executes it. This is most often used
to perform an ``internal redirect'' to a new component such that
autohandlers and dhandlers take effect.
</dd>
<p></p>
<dt><strong><A NAME="item_time">time</a></strong><br />
</dt>
<dd>
Returns the interpreter's notion of the current time (deprecated).
</dd>
<p></p></dl>
<p>
</p>
<hr />
<h1><A NAME="apacheonly_methods">APACHE-ONLY METHODS</a></h1>
<p>These additional methods are available when running Mason with mod_perl
and the ApacheHandler.</p>
<A NAME="item_ah"></a><dl>
<dt><strong><A NAME="item_ah">ah</a></strong><br />
</dt>
<dd>
Returns the ApacheHandler object associated with this request.
</dd>
<A NAME="item_apache_req"></a><p></p>
<dt><strong><A NAME="item_apache_req">apache_req</a></strong><br />
</dt>
<dd>
Returns the Apache request object.  This is also available in the
global <code>$r</code>.
</dd>
<A NAME="item_auto_send_headers"></a><p></p>
<dt><strong><A NAME="item_auto_send_headers">auto_send_headers</a></strong><br />
</dt>
<dd>
True or false, default is true.  Indicates whether Mason should
automatically send HTTP headers before sending content back to the
client. If you set to false, you should call <code>$r-&gt;send_http_header</code>
manually.
</dd>
<dd>
<p>See the <A HREF="Devel.html#sending_http_headers">sending HTTP headers</a> section of the developer's manual for more details about the automatic
header feature.</p>
</dd>
<p></p></dl>
<p>
</p>
<hr />
<h1><A NAME="cgionly_methods">CGI-ONLY METHODS</a></h1>
<p>This additional method is available when running Mason with the
CGIHandler module.</p>
<A NAME="item_cgi_request"></a><dl>
<dt><strong><A NAME="item_cgi_request">cgi_request</a></strong><br />
</dt>
<dd>
Returns the Apache request emulation object, which is available as
<code>$r</code> inside components.
</dd>
<dd>
<p>See the <A HREF="CGIHandler.html#_r_methods">CGIHandler docs</a> for
more details.</p>
</dd>
<p></p></dl>
<p>
</p>
<hr />
<h1><A NAME="apache_or_cgionly_methods">APACHE- OR CGI-ONLY METHODS</a></h1>
<p>This method is available when Mason is running under either the
ApacheHandler or CGIHandler modules.</p>
<A NAME="item_cgi_object"></a><dl>
<dt><strong><A NAME="item_cgi_object">cgi_object</a></strong><br />
</dt>
<dd>
Returns the CGI object used to parse any CGI parameters submitted to
the component, assuming that you have not changed the default value of
the ApacheHandler <A HREF="Params.html#args_method">args_method</a> parameter.  If you are using the
'mod_perl' args method, then calling this method is a fatal error.
See the <a HREF="ApacheHandler.html">ApacheHandler</a> and
<a HREF="CGIHandler.html">CGIHandler</a> documentation for more details.
</dd>
<A NAME="item_redirect_url_status_"></a><p></p>
<dt><strong><A NAME="item_redirect">redirect ($url, [$status])</a></strong><br />
</dt>
<dd>
Given a url, this generates a proper HTTP redirect for that URL. It
uses <A HREF="#item_clear_buffer"><code>$m-&gt;clear_buffer</code></a> to clear out any previous output, and <code>&lt;
$m-</code>abort &gt;&gt; to abort the request.  By default, the status code used
is 302, but this can be overridden by the user.
</dd>
<dd>
<p>Since this is implemented using <A HREF="#item_abort"><code>$m-&gt;abort</code></a>, it will be trapped
by an <code> eval {} </code> block.  If you are using an <code> eval {} </code> block in
your code to trap errors, you need to make sure to rethrow these
exceptions, like this:</p>
</dd>
<dd>
<pre>
  eval {
      ...
  };</pre>
</dd>
<dd>
<pre>
  die $@ if $m-&gt;aborted;</pre>
</dd>
<dd>
<pre>
  # handle other exceptions</pre>
</dd>
<p></p></dl>
<p>
</p>
<hr />
<h1><A NAME="authors">AUTHORS</a></h1>
<p>Jonathan Swartz &lt;<a href="mailto:swartz@pobox.com">swartz@pobox.com</a>&gt;, Dave Rolsky &lt;<a href="mailto:autarch@urth.org">autarch@urth.org</a>&gt;, Ken Williams &lt;<a href="mailto:ken@mathforum.org">ken@mathforum.org</a>&gt;</p>
<p>
</p>
<hr />
<h1><A NAME="see_also">SEE ALSO</a></h1>
<p><a HREF="Mason.html">HTML::Mason</a>,
<a HREF="Devel.html">HTML::Mason::Devel</a>,
<a HREF="Component.html">HTML::Mason::Component</a>

</p>

</body>

</html>
