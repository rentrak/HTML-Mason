    <HTML> 
	<HEAD> 
	    <TITLE>Devel.pod - Mason Developer's Manual

</TITLE> 
	</HEAD>

	<BODY>

<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#name">NAME</A>
	<LI><A HREF="#description">DESCRIPTION</A>
	<LI><A HREF="#what_are_components_">WHAT ARE COMPONENTS?</A>
	<LI><A HREF="#in_line_perl_sections">IN-LINE PERL SECTIONS </A>
	<UL>

		<LI><A HREF="#examples_and_recommended_usage">Examples and Recommended Usage</A>
	</UL>

	<LI><A HREF="#calling_components">CALLING COMPONENTS</A>
	<UL>

		<LI><A HREF="#components_that_output_html">Components that output HTML</A>
		<LI><A HREF="#components_that_compute_values">Components that compute values</A>
	</UL>

	<LI><A HREF="#top_level_components">TOP-LEVEL COMPONENTS</A>
	<UL>

		<LI><A HREF="#dhandlers">dhandlers</A>
		<LI><A HREF="#autohandlers">autohandlers</A>
		<LI><A HREF="#dhandlers_vs_autohandlers">dhandlers vs. autohandlers</A>
	</UL>

	<LI><A HREF="#passing_parameters">PASSING PARAMETERS</A>
	<UL>

		<LI><A HREF="#in_component_calls">In Component Calls</A>
		<LI><A HREF="#in_http_requests">In HTTP requests</A>
		<LI><A HREF="#accessing_parameters">Accessing Parameters</A>
		<LI><A HREF="#parameter_passing_examples">Parameter Passing Examples</A>
	</UL>

	<LI><A HREF="#other_perl_sections">OTHER PERL SECTIONS</A>
	<UL>

		<LI><A HREF="#e_lt_inite_gt_">&lt;%init&gt;</A>
		<LI><A HREF="#e_lt_cleanupe_gt_">&lt;%cleanup&gt;</A>
		<LI><A HREF="#e_lt_argse_gt_">&lt;%args&gt;</A>
		<LI><A HREF="#e_lt_oncee_gt_">&lt;%once&gt;</A>
		<LI><A HREF="#e_lt_def_i_name_e_gt_">&lt;%def <EM>name</EM>&gt;</A>
		<LI><A HREF="#e_lt_filtere_gt_">&lt;%filter&gt;</A>
		<LI><A HREF="#e_lt_doce_gt_">&lt;%doc&gt;</A>
		<LI><A HREF="#e_lt_texte_gt_">&lt;%text&gt;</A>
		<LI><A HREF="#_at_end_of_line">\ at end of line</A>
	</UL>

	<LI><A HREF="#data_caching">DATA CACHING</A>
	<UL>

		<LI><A HREF="#basic_usage">Basic Usage</A>
		<LI><A HREF="#multiple_keys_values">Multiple Keys/Values</A>
		<LI><A HREF="#expiration">Expiration</A>
		<LI><A HREF="#busy_locks">Busy Locks</A>
		<LI><A HREF="#keeping_in_memory">Keeping In Memory</A>
		<LI><A HREF="#caching_all_output">Caching All Output </A>
		<LI><A HREF="#guarantees_or_lack_thereof_">Guarantees (or lack thereof)</A>
	</UL>

	<LI><A HREF="#filtering">FILTERING</A>
	<UL>

		<LI><A HREF="#_lt_filter_gt_section">&lt;%filter&gt; section</A>
		<LI><A HREF="#mc_call_self_command">mc_call_self command</A>
		<LI><A HREF="#how_filtering_works">How filtering works</A>
	</UL>

	<LI><A HREF="#accessing_server_internals">ACCESSING SERVER INTERNALS</A>
	<LI><A HREF="#sending_http_headers">SENDING HTTP HEADERS</A>
	<LI><A HREF="#component_and_request_objects">COMPONENT AND REQUEST OBJECTS</A>
	<LI><A HREF="#using_the_perl_debugger">USING THE PERL DEBUGGER</A>
	<UL>

		<LI><A HREF="#using_debug_files">Using debug files</A>
		<LI><A HREF="#specifying_when_to_create_debug_">Specifying when to create debug files</A>
		<LI><A HREF="#how_debug_files_work">How debug files work</A>
		<LI><A HREF="#when_debug_files_don_t_work">When debug files don't work</A>
	</UL>

	<LI><A HREF="#using_the_perl_profiler">USING THE PERL PROFILER</A>
	<LI><A HREF="#the_previewer">THE PREVIEWER</A>
	<LI><A HREF="#tips_and_traps">TIPS AND TRAPS</A>
	<LI><A HREF="#author">AUTHOR</A>
	<LI><A HREF="#see_also">SEE ALSO</A>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="name">NAME

</A></H1>
Devel.pod - Mason Developer's Manual


<P>

<P>
<HR>
<H1><A NAME="description">DESCRIPTION

</A></H1>
This manual is written for content developers who know HTML and at least a
little Perl. The goal is to write, run, and debug Mason components.


<P>

If you are the webmaster (or otherwise responsible for the Mason
installation), you should also read <STRONG>HTML::Mason::Admin</STRONG>. There you will find FAQs about virtual site configuration, performance
tuning, component caching, and so on.


<P>

I strongly suggest that you have a working Mason to play with as you work
through these examples. Other component examples can be found in the <CODE>samples/</CODE> directory.


<P>

<P>
<HR>
<H1><A NAME="what_are_components_">WHAT ARE COMPONENTS?

</A></H1>
The component - a mix of Perl and HTML - is Mason's basic building block
and computational unit. Under Mason, web pages are formed by combining the
output from multiple components. An article page for a news publication,
for example, might call separate components for the company masthead, ad
banner, left table of contents, and article body. Consider this layout
sketch:


<P>

<PRE>    +---------+------------------+
    |Masthead | Banner Ad        |
    +---------+------------------+
    |         |                  |
    |+-------+|Text of Article ..|
    ||       ||                  |
    ||Related||Text of Article ..|
    ||Stories||                  |
    ||       ||Text of Article ..|
    |+-------+|                  |
    |         +------------------+
    |         | Footer           |
    +---------+------------------+
</PRE>

<P>

The top level component decides the overall page layout, perhaps with HTML
tables. Individual cells are then filled by the output of subordinate
components, one for the Masthead, one for the Footer, etc. In practice
pages are built up from as few as one, to as many as twenty or more
components.


<P>

This component approach reaps many benefits in a web environment. The first
benefit is <EM>consistency</EM>: by embedding standard design elements in components, you ensure a
consistent look and make it possible to update the entire site with just a
few edits. The second benefit is <EM>concurrency</EM>: in a multi-person environment, one person can edit the masthead while
another edits the table of contents. A last benefit is <EM>reuseability</EM>: a component produced for one site might be useful on another. You can
develop a library of generally useful components to employ on your sites
and to share with others.


<P>

Most components emit chunks of HTML. ``Top level'' components, invoked from
a URL, represent an entire web page. Other, subordinate components emit
smaller bits of HTML destined for inclusion in top level components.


<P>

Components receive form and query data from HTTP requests. When called from
another component, they can accept arbitrary parameter lists just like a
subroutine, and optionally return values. This enables a type of component
that does not print any HTML, but simply serves as a function, computing
and returning a result.


<P>

Mason actually compiles components down to Perl subroutines, so you can
debug and profile component-based web pages with standard Perl tools that
understand the subroutine concept, e.g. you can use the Perl debugger to
step through components, and <STRONG>Devel::DProf</STRONG> to profile their performance.


<P>

<P>
<HR>
<H1><A NAME="in_line_perl_sections">IN-LINE PERL SECTIONS 

</A></H1>
Here is a simple component example:


<P>

<PRE>    &lt;%perl&gt;
    my $noun = 'World';
    my @time = split /[\s:]/, localtime;
    &lt;/%perl&gt;
    Hello &lt;% $noun %&gt;,
    % if ( $time[3] &lt; 12 ) {
    good morning.
    % } else {
    good afternoon.
    % }
</PRE>

<P>

After 12 pm, the output of this component is:


<P>

<PRE>    Hello world, good afternoon.
</PRE>

<P>

This short example demonstrates the three primary ``in-line'' Perl
sections. In-line sections are generally embedded within HTML and execute
in the order they appear. Other, specialized Perl sections are tied to
component events like initialization and cleanup, argument definition, etc.
Those are covered later in <EM><A HREF="#other_perl_sections">Other Perl Sections</A></EM>.


<P>

The parsing rules for these Perl sections are as follows:


<P>

<OL>
<LI><STRONG><A NAME="item_">

</A></STRONG>
Blocks of the form &lt;% xxx %&gt; are replaced with the result of
evaluating xxx as a single Perl expression. These are often used for
variable replacement. such as 'Hello, &lt;% <CODE>$name</CODE> %&gt;!'.


<P>

<LI><STRONG><A NAME="item_">

</A></STRONG>
Lines beginning with a '%' character are treated as Perl. 


<P>

<LI><STRONG><A NAME="item_">

</A></STRONG>
Multiline blocks of Perl code can be inserted with the &lt;%perl&gt; ..
&lt;/%perl&gt; tag. The enclosed text is executed as Perl and the return
value, if any, is discarded.


<P>

The &lt;%perl&gt; tag is case-insensitive. It may appear anywhere in the
text, and may span any number of lines. &lt;%perl&gt; blocks cannot be
nested inside one another.


<P>

</OL>
In addition to Perl code, Perl sections may also contain <EM>Mason
commands</EM>. These keywords, identified by their mc_ prefix, collectively provide an
interface to Mason services such as data caching, file includes, and so on. <STRONG><A HREF="././Commands.html#">HTML::Mason::Commands</A></STRONG> is the reference for all Mason commands.


<P>

<P>
<HR>
<H2><A NAME="examples_and_recommended_usage">Examples and Recommended Usage

</A></H2>
<STRONG>% lines</STRONG>




<P>

Most useful for conditional and loop structures - if, while, foreach, ,
etc. - as well as side-effect commands like assignments. Examples:


<P>

o Conditional code


<P>

<PRE>    % my $ua = $r-&gt;header_in('User-Agent');
    % if ($ua =~ /msie/i) {
    Welcome, Internet Explorer users
    ...
    % } elsif ($ua =~ /mozilla/i) {
    Welcome, Netscape users
    ...
    % }
</PRE>

<P>

o HTML list formed from array


<P>

<PRE>    &lt;ul&gt;
    % foreach $item (@list) {
    &lt;li&gt;&lt;% $item %&gt;
    % }
    &lt;/ul&gt;
</PRE>

<P>

o HTML list formed from hash


<P>

<PRE>    &lt;ul&gt;
    % while (my ($key,$value) = each(%ENV)) {
    &lt;li&gt;
    &lt;b&gt;&lt;% $key %&gt;&lt;/b&gt;: &lt;% $value %&gt;
    % }
    &lt;/ul&gt;
</PRE>

<P>

o HTML table formed from list of hashes


<P>

<PRE>    &lt;table&gt;
    &lt;tr&gt;
    % foreach my $h (@loh) {
    &lt;td&gt;&lt;% $h-&gt;{foo} %&gt;&lt;/td&gt;
    &lt;td bgcolor=#ee0000&gt;&lt;% $h-&gt;{bar} %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;% $h-&gt;{baz} %&gt;&lt;/td&gt;
    % }
    &lt;/tr&gt;
    &lt;/table&gt;
</PRE>

<P>

For more than three lines of Perl, consider using a &lt;%perl&gt; block.


<P>

<STRONG>&lt;% xxx %&gt;</STRONG>




<P>

Most useful for printing out variables, as well as more complex
expressions. Examples:


<P>

<PRE>  Dear &lt;% $name %&gt;: We will come to your house at &lt;% $address %&gt; in the
  fair city of &lt;% $city %&gt; to deliver your $&lt;% $amount %&gt; dollar prize!
</PRE>

<P>

<PRE>  The answer is &lt;% ($y+8) % 2 %&gt;.
</PRE>

<P>

<PRE>  You are &lt;% $age&lt;18 ? 'not' : '' %&gt; permitted to enter this site.
</PRE>

<P>

For side-effect commands like assignments, consider using a % line or
&lt;%perl&gt; block instead.


<P>

<STRONG>&lt;%perl&gt; xxx &lt;%/perl&gt;</STRONG>




<P>

Useful for Perl blocks of more than a few lines. For a very small block,
consider using % lines.


<P>

<P>
<HR>
<H1><A NAME="calling_components">CALLING COMPONENTS

</A></H1>
Mason pages often are built not from a single component, but from multiple
components that call each other in a hierarchical fashion.


<P>

<P>
<HR>
<H2><A NAME="components_that_output_html">Components that output HTML

</A></H2>
To call one component from another, use the &lt;&amp; &amp;&gt; tag:


<P>

<PRE>    &lt;&amp; compPath, [name=&gt;value, ...], [STORE=&gt;ref] &amp;&gt;
</PRE>

<P>

<DL>
<DT><STRONG><A NAME="item_compPath_">compPath:

</A></STRONG><DD>
The component path. With a leading '/', the path is relative to the
component root (<A HREF="././Interp.html#item_comp_root">comp_root</A>). Otherwise, it is relative to the location of the calling component.


<P>

<DT><STRONG><A NAME="item_name_value_pairs_">name=&gt;value pairs:

</A></STRONG><DD>
Parameters are passed as one or more name=&gt;value pairs, e.g. <CODE>player=&gt;'M.&nbsp;Jordan'</CODE>. 


<P>

<DT><STRONG><A NAME="item_STORE_ref_">STORE=&gt;ref:

</A></STRONG><DD>
The optional <EM>STORE</EM> parameter takes a scalar reference as an argument, and tells the component
to direct its output into the named variable instead of standard output.
This is analogous to the difference between sprintf and printf.


<P>

</DL>
Mason uses a bit of magic parsing to eliminate the need for quotes around
the component path in common cases. If the first character is one of <CODE>[A-Za-z0-9/_.]</CODE>, the component path is assumed to be a literal string running up to the
first comma or &amp;&gt;. Otherwise, the component path is evaluated as an
expression.


<P>

Here are some examples:


<P>

<PRE>    # relative component paths
    &lt;&amp; topimage &amp;&gt;
    &lt;&amp; tools/searchbox &amp;&gt;
</PRE>

<P>

<PRE>    # absolute component path
    &lt;&amp; /shared/masthead, color=&gt;'salmon' &amp;&gt;
</PRE>

<P>

<PRE>    # use STORE option to place output in variable
    &lt;&amp; /shared/masthead, color=&gt;'salmon', STORE=&gt;\$mh_text &amp;&gt;
</PRE>

<P>

<PRE>    # this component path MUST have quotes because it contains a comma
    &lt;&amp; &quot;sugar,eggs&quot;, mix=&gt;1 &amp;&gt;
</PRE>

<P>

<PRE>    # variable component path
    &lt;&amp; $comp &amp;&gt;
    
    # variable component and arguments
    &lt;&amp; $comp, %args &amp;&gt;
</PRE>

<P>

<PRE>    # you can use arbitrary expression for component path, but it cannot
    # begin with a letter or number; delimit with () to remedy this
    &lt;&amp; (int(rand(2)) ? 'thiscomp' : 'thatcomp'), id=&gt;123 &amp;&gt;
</PRE>

<P>

<P>
<HR>
<H2><A NAME="components_that_compute_values">Components that compute values

</A></H2>
So far you have seen components used solely to output HTML. However,
components may also be used to compute a value. For example, you might have
a component <CODE>isNetscape</CODE> that analyzes the user agent to determine whether it is a Netscape browser:


<P>

<PRE>    &lt;%perl&gt;
    mu $ua = $r-&gt;header_in('User-Agent');
    return ($ua =~ /Mozilla/i &amp;&amp; $ua !~ /MSIE/i) ? 1 : 0;
    &lt;/%perl&gt;
</PRE>

<P>

Because components are implemented underneath with Perl subroutines, they
can return values and even understand scalar/list context.


<P>

The &lt;&amp; &amp;&gt; notation only calls a component for its
side-effect, and discards its return value, if any. To get at the return
value of a component, use the mc_comp command:


<P>

<PRE>    % if (mc_comp('isNetscape')) {
    Welcome, Netscape user!
    % }
</PRE>

<P>

Mason adds a <CODE>return undef</CODE> to the bottom of each component to provide an empty default return value.
To return your own value from a component, you <EM>must</EM> use an explicit <CODE>return</CODE> statement.


<P>

Generally components are divided into two types: those that output HTML,
and those that return a value. There is very little reason for a component
to do both. For example, it would not be very friendly for <CODE>isNetscape</CODE> to output ``hi Mom'' while it was computing its value, thereby surprising
the <CODE>if</CODE> statement! Conversely, any value returned by an HTML component would
typically be discarded by the &lt;&amp; &amp;&gt; tag that invoked it.


<P>

Prior to version 0.6, mc_comp was the only way to call components even for
outputting HTML:


<P>

<PRE>    &lt;% mc_comp('/shared/masthead', color=&gt;'salmon') %&gt;
</PRE>

<P>

This is still legal, although &lt;&amp; &amp;&gt; is the official syntax. If you have pre-0.6 components that
you'd like to convert to use &lt;&amp; &amp;&gt;, check out the utility <EM>bin/convert0.6.pl</EM>.


<P>

<P>
<HR>
<H1><A NAME="top_level_components">TOP-LEVEL COMPONENTS

</A></H1>
The first component invoked for a page (the ``top-level component'')
resides within the DocumentRoot and is chosen based on the URL. For
example:


<P>

<PRE>    http://www.foo.com/mktg/products?id=372
</PRE>

<P>

Apache resolves this URL to a filename, e.g.
/usr/local/www/htdocs/mktg/prods.html. Mason loads and executes that file
as a component. In effect, Mason calls


<P>

<PRE>    mc_comp('/mktg/products', id=&gt;372)
</PRE>

<P>

This component might in turn call other components and execute some Perl
code, or it might be nothing more than static HTML.


<P>

<P>
<HR>
<H2><A NAME="dhandlers">dhandlers

</A></H2>
What happens when a user requests a component that doesn't exist? In this
case Mason scans backward through the URI, checking each directory for a
component named <EM>dhandler</EM> (``default handler''). If found, the dhandler is invoked and is expected to
use
<CODE>$r-&gt;path_info</CODE> (the virtual location) as the parameter to some access function, perhaps a
database lookup or location in another filesystem. In a sense, dhandlers
are similar in spirit to Perl's AUTOLOAD feature; they are the ``component
of last resort'' when a URL points to a non-existent component.


<P>

Consider the following URL, in which <CODE>newsfeeds/</CODE> exists but not the subdirectory <CODE>LocalNews</CODE> nor the component <CODE>Story1</CODE>:


<P>

<PRE>    http://myserver/newsfeeds/LocalNews/Story1
</PRE>

<P>

In this case Mason constructs the following search path:


<P>

<PRE>    /newsfeeds/LocalNews/Story1         =&gt; no such thing
    /newsfeeds/LocalNews/dhandler       =&gt; no such thing
    /newsfeeds/dhandler                 =&gt; found! (search ends)
    /dhandler
</PRE>

<P>

The found dhandler would read ``/LocalNews/Story1'' from
<CODE>$r-&gt;path_info</CODE> and use it as a retrieval key into a database of stories. Optionally, the
Mason command
<A HREF="././Commands.html#item_mc_dhandler_arg">mc_dhandler_arg()</A> returns the same path_info stripped of the leading slash
(``LocalNews/locStory1.html'').


<P>

Here's how a simple /newsfeeds/dhandler might look:


<P>

<PRE>    &lt;&amp; header &amp;&gt;
    &lt;b&gt;&lt;% $headline %&gt;&lt;/b&gt;&lt;p&gt;
    &lt;% $body %&gt;
    &lt;&amp; footer &amp;&gt;
    
    &lt;%init&gt;
    my $arg = mc_dhandler_arg();               # get rest of path
    my ($section,$story) = split(&quot;/&quot;,$arg);    # split out pieces
    my $sth = $DBH-&gt;prepare
        (&quot;SELECT headline,body FROM news WHERE section='$section' AND story='$story'&quot;);
    my ($headline,$body) = $sth-&gt;fetchrow_array;
    return 404 if !$headline;                  # return &quot;not found&quot; if no such story
    &lt;/%init&gt;
</PRE>

<P>

You can customize the file name used for dhandlers, or turn off
autohandlers entirely, with the <A HREF="./Interp.html#item_dhandler_name">dhandler_name</A> Interp parameter.


<P>

<P>
<HR>
<H2><A NAME="autohandlers">autohandlers

</A></H2>
Autohandlers allow you to grab control and perform some action just before
Mason calls the top-level component. This might mean adding a standard
header and footer, applying an output filter, or setting up global
variables.


<P>

Autohandlers are directory based. When Mason determines the top-level
component, it checks that directory for a component called ``autohandler'';
if it exists, it is called instead. After performing its actions, the
autohandler typically calls <A HREF="././Commands.html#item_mc_auto_next">mc_auto_next</A> to transfer control to the original intended component.


<P>

<A HREF="././Commands.html#item_mc_auto_next">mc_auto_next</A> works just like <A HREF="././Commands.html#item_mc_comp">mc_comp</A> except that the component path and arguments are implicit. You can pass
additional arguments to
<A HREF="././Commands.html#item_mc_auto_next">mc_auto_next</A>; these are merged with the original arguments, taking precedence in case
of conflict. This allows you, for example, to override arguments passed in
the URL. The STORE option also works if you want to store and process the
component output.


<P>

Here is an autohandler that adds a common header and footer to each page in
the directory:


<P>

<PRE>    &lt;HTML&gt;
    &lt;HEAD&gt;&lt;TITLE&gt;McHuffy Incorporated&lt;/TITLE&gt;&lt;/HEAD&gt;
    &lt;BODY BGCOLOR=&quot;salmon&quot;&gt;
    
    &lt;% mc_auto_next %&gt;
    
    &lt;HR&gt;
    Copyright 1999 McHuffy Inc.
    &lt;/BODY&gt;
    &lt;/HTML&gt;
</PRE>

<P>

Same idea, with separate components for header/footer in the same
directory:


<P>

<PRE>    &lt;&amp; header &amp;&gt;
    &lt;% mc_auto_next %&gt;
    &lt;&amp; footer &amp;&gt;
</PRE>

<P>

The next autohandler applies a filter to its pages, adding an absolute
hostname to relative image URLs:


<P>

<PRE>    &lt;%init&gt;
    my $buf;
    mc_auto_next(STORE=&gt;\$buf);
    $buf =~ s{(&lt;img\s+src=\&quot;)/} {$1http://images.mysite.com}ig;
    mc_out($buf);
    &lt;/%init&gt;
</PRE>

<P>

The same, using a &lt;%filter&gt; tag:


<P>

<PRE>    &lt;% mc_auto_next %&gt;
    
    &lt;%filter&gt;
    s{(&lt;img\s+src=\&quot;)/} {$1http://images.mysite.com}ig;
    &lt;/%filter&gt;
</PRE>

<P>

Most of the time autohandler can simply call <A HREF="././Commands.html#item_mc_auto_next">mc_auto_next</A> without needing to know what component was called. However, should you need
it, the relative component path is available from <A HREF="././Commands.html#item_mc_auto_comp">mc_auto_comp</A>. For example, here we base the page title partly on the component name:


<P>

<PRE>    &lt;HTML&gt;
    &lt;HEAD&gt;&lt;TITLE&gt;McHuffy Incorporated: &lt;% $section %&gt;&lt;/TITLE&gt;&lt;/HEAD&gt;
    &lt;% mc_auto_next %&gt;
    &lt;/BODY&gt;
    &lt;/HTML&gt;
    
    &lt;%init&gt;
    my $comp = mc_auto_comp();
    my $section = ($comp eq 'mktg.html' ? 'Marketing' : ...);
    &lt;/%init&gt;
</PRE>

<P>

<A HREF="././Commands.html#item_mc_auto_comp">mc_auto_comp</A> is also useful for calling the component manually, e.g. if you want to
suppress one or more original arguments.


<P>

By default autohandlers apply only to the current directory, not to its
subdirectories. The Mason administrator can turn on the flag
<A HREF="./Interp.html#item_allow_recursive_autohandlers">allow_recursive_autohandlers</A> that makes autohandlers apply to all subdirectories. Be warned that this
mode entails a performance and readability cost. On every request Mason has
to scan not only the current directory but all parent directories for a
file named ``autohandler''. Likewise, someone trying to determine how a
page is rendered has to scan through parent directories.


<P>

That said, the applications of recursive autohandlers (e.g. applying a
site-wide template) can be compelling enough to overcome these
disadvantages.


<P>

If you have recursive mode turned on but want a particular autohandler to
apply only to the current directory, use a conditional like this:


<P>

<PRE>    &lt;%init&gt;
    return mc_auto_continue if (mc_auto_comp =~ /\//);
    ... rest of autohandler ...
    &lt;/%init&gt;
</PRE>

<P>

You can customize the file name used for autohandlers, or turn off
autohandlers entirely, with the <A HREF="./Interp.html#item_autohandler_name">autohandler_name</A>
Interp parameter.


<P>

<P>
<HR>
<H2><A NAME="dhandlers_vs_autohandlers">dhandlers vs. autohandlers

</A></H2>
dhandlers and autohandlers both provide a way to exert control over a large
set of URLs. However, each specializes in a very different application. The
key difference is that dhandlers are invoked only when no appropriate
component exists, while autohandlers are invoked only in conjunction with a
matching component.


<P>

As a rule of thumb: use an autohandler when you have a set of components to
handle your pages and you want to augment them with a template/filter. Use
a dhandler when you want to create a set of ``virtual URLs'' that don't
correspond to any actual components, or to provide default behavior for a
directory.


<P>

dhandlers and autohandlers can even be used in the same directory. For
example, you might have a mix of real URLs and virtual URLs to which you
would like to apply a common template/filter.


<P>

Prior to version 0.6, dhandlers were the only way to accomplish tasks like
applying a standard template across multiple components. However, this
application of dhandlers has several disadvantages. First, you must
perversely ``hide'' your existing components so that Mason will not find
them and instead invoke the dhandler! Second, you must manually check
whether the subsequent component exists and handle ``not found'' errors.
The upshot is that autohandlers are better suited for many tasks previously
solved by dhandlers.


<P>

<P>
<HR>
<H1><A NAME="passing_parameters">PASSING PARAMETERS

</A></H1>
This section describes Mason's facilities for passing parameters to
components (either from HTTP requests or component calls) and for accessing
parameter values inside components.


<P>

<P>
<HR>
<H2><A NAME="in_component_calls">In Component Calls

</A></H2>
Any Perl data type can be passed in a component call:


<P>

<PRE>    &lt;&amp; /sales/header, s=&gt;'dog', l=&gt;[2,3,4], h=&gt;{a=&gt;7,b=&gt;8} &amp;&gt;
</PRE>

<P>

This command passes a scalar ($s), a list (@l), and a hash (%h). The list
and hash must be passed as references, but they will be automatically
dereferenced in the called component.


<P>

<P>
<HR>
<H2><A NAME="in_http_requests">In HTTP requests

</A></H2>
Consider a CGI-style URL with a query string:


<P>

<PRE>    http://www.foo.com/mktg/prods.html?str=dog&amp;lst=2&amp;lst=3&amp;lst=4
</PRE>

<P>

or an HTTP request with some POST content. Mason automatically parses the
GET/POST values and makes them available to the component as parameters.


<P>

<P>
<HR>
<H2><A NAME="accessing_parameters">Accessing Parameters

</A></H2>
Component parameters, whether they come from GET/POST or another component,
can be accessed in two ways.


<P>

1. Declared named arguments: Components can define a
<CODE>&lt;%args%&gt;</CODE> section listing argument names, types, and default values, with optional
comments. For example:


<P>

<PRE>    &lt;%args&gt;
    $a       
    @b       # a comment
    %c
    $d=&gt;5    # another comment
    @e=&gt;('foo','baz')
    %f=&gt;(joe=&gt;1,bob=&gt;2)
    &lt;/%args&gt;
</PRE>

<P>

Here, $a, @b, and <CODE>%c</CODE> are required arguments; the component
generates an error if the caller leaves them unspecified. $d, @e, and
<CODE>%f</CODE> are optional arguments; they are assigned the specified
default values if unspecified. All the arguments are available as lexically
scoped (``my'') variables in the rest of the component.


<P>

2. <CODE>%ARGS</CODE> hash: This variable, always available, contains all
of the parameters passed to the component. It is especially handy when
there are many parameters or when parameter names are determined at
run-time. <CODE>%ARGS</CODE> can be used whether or not you have a
&lt;%args&gt; ... &lt;/%args&gt; section.


<P>

Here's how to pass all of a component's parameters to another component:


<P>

<PRE>    &lt;&amp; template, %ARGS &amp;&gt;
</PRE>

<P>

<P>
<HR>
<H2><A NAME="parameter_passing_examples">Parameter Passing Examples

</A></H2>
The following examples illustrate the different ways to pass and receive
parameters.


<P>

1. Passing a scalar <EM>id</EM> with value 5.


<P>

<PRE>  In a URL: /my/URL?id=5
  In a component call: &lt;&amp; /my/comp, id =&gt; 5 &amp;&gt;
  In the called component, if there is a declared argument named...
    $id, then $id will equal 5
    @id, then @id will equal (5)
    %id, then an error occurs
  In addition, $ARGS{id} will equal 5.
</PRE>

<P>

2. Passing a list <EM>colors</EM> with values red, blue, and green.


<P>

<PRE>  In a URL: /my/URL?colors=red&amp;colors=blue&amp;colors=green
  In an component call: &lt;&amp; /my/comp, colors =&gt; ['red', 'blue', 'green'] &amp;&gt;
  In the called component, if there is a declared argument named...
    $colors, then $colors will equal ['red', 'blue', 'green']
    @colors, then @colors will equal ('red', 'blue', 'green')
    %colors, then an error occurs
  In addition, $ARGS{colors} will equal ['red', 'blue', 'green'].
</PRE>

<P>

3. Passing a hash <EM>grades</EM> with pairs Alice =&gt; 92 and Bob =&gt; 87.


<P>

<PRE>  In a URL: /my/URL?grades=Alice&amp;grades=92&amp;grades=Bob&amp;grades=87
  In an component call: &lt;&amp; /my/comp', grades =&gt; {Alice =&gt; 92, Bob =&gt; 87} &amp;&gt;
  In the called component, if there is a declared argument named...
    $grades, then $grades will equal {Alice =&gt; 92, Bob =&gt; 87}
    @grades, then @grades will equal ('Alice', 92, 'Bob', 87)
    %grades, then %grades will equal (Alice =&gt; 92, Bob =&gt; 87)
  In addition, $ARGS{grades} will equal {Alice =&gt; 92, Bob =&gt; 87}.
</PRE>

<P>

<P>
<HR>
<H1><A NAME="other_perl_sections">OTHER PERL SECTIONS

</A></H1>
In this section we describe other specialized sections you can place in
your component. Several are tied to phases of the component execution
sequence, which goes something like this:


<P>

<PRE>    1. Initialize arguments declared in &lt;%args&gt; section
    2. &lt;%init&gt; section
    3. Output HTTP headers (if not output already)
    4. Primary section (HTML + embedded Perl sections)
    5. &lt;%cleanup&gt; section
</PRE>

<P>

Prior to version 0.6, section names were all prefixed with perl_: &lt;%perl_init&gt;, &lt;%perl_cleanup&gt;, etc. For backwards compatibility these names are still
recognized, but the short names are preferred. If you have pre-0.6
components that you'd like to convert, a convenient utility exists in <EM>bin/convert0.6.pl</EM>.


<P>

<P>
<HR>
<H2><A NAME="e_lt_inite_gt_">&lt;%init&gt;

</A></H2>
Used for initialization code. For example: connecting to a database and
selecting out rows; opening a file and reading its contents into a list.


<P>

Technically a &lt;%init&gt; block is equivalent to a &lt;%perl&gt; block at
the beginning of the component. However, there is an aesthetic advantage of
placing this block at the end of the component rather than the beginning.
In the following example, a database query is used to preload the
<CODE>@persons</CODE> list-of-hashes; it lets us hide the technical details
at the bottom.


<P>

<PRE>    &lt;H2&gt;Birthdays Next Week&lt;/H2&gt;
    &lt;TABLE BORDER=1&gt;
    &lt;TR&gt;&lt;TH&gt;Name&lt;/TH&gt;&lt;TH&gt;Birthday&lt;/TH&gt;&lt;/TR&gt;
    % foreach (@persons) {
        &lt;TR&gt;&lt;TD&gt;&lt;%$_-&gt;{name}%&gt;&lt;/TD&gt;&lt;TD&gt;&lt;%$_-&gt;{birthday}%&gt;&lt;/TD&gt;&lt;/TR&gt;
    % }
    &lt;/TABLE&gt;
</PRE>

<P>

<PRE>    &lt;%INIT&gt;
    # Assuming DBI/DBD and Date::Manip are already loaded ...
    # Query MySQL for employees with birthdays next week.
    # Results are stored in the @persons list-of-hashes.
</PRE>

<P>

<PRE>    my (@persons, $name, $birthday);    # local vars
</PRE>

<P>

<PRE>    # Calculate &quot;MM-DD&quot; dates for this and next Sunday
    my $Sun = UnixDate(&amp;ParseDate(&quot;Sunday&quot;), &quot;%m-%d&quot;);
    my $nextSun = UnixDate(&amp;DateCalc(&quot;Sunday&quot;, &quot;+7 days&quot;), &quot;%m-%d&quot;);
</PRE>

<P>

<PRE>    my $dbh = DBI-&gt;connect('DBI:mysql:myDB', 'nobody' );
    my $sth = $dbh-&gt;prepare(
       qq{ SELECT name, DATE_FORMAT(birthday, 'm-d')
           FROM emp
           WHERE DATE_FORMAT(birthday,'m-d') BETWEEN '$Sun' AND '$nextSun'
         } );
    $sth-&gt;execute;              # other DBDs want this after the bind
    $sth-&gt;bind_columns(undef, \($name, $birthday) );
</PRE>

<P>

<PRE>    while ($sth-&gt;fetch) {
        push (@persons, {name=&gt;$name, birthday=&gt;$birthday} );
    }
    &lt;/%INIT&gt;
</PRE>

<P>

Since <CODE>&lt;%init&gt;</CODE> sections fire before any HTTP headers are sent, they should do their work
quickly to prevent dead time on the browser side.


<P>

<P>
<HR>
<H2><A NAME="e_lt_cleanupe_gt_">&lt;%cleanup&gt;

</A></H2>
Used for cleanup code. For example: closing a database connection or
closing a file handle.


<P>

Technically a &lt;%cleanup&gt; block is equivalent to a &lt;%perl&gt; block
at the end of the component, but has aesthetic value as marking a cleanup
section.


<P>

Recall that the end of a component corresponds to the end of a subroutine
block. Since Perl is so darned good at cleaning up stuff at the end of
blocks, &lt;%cleanup&gt; sections are rarely needed.


<P>

<P>
<HR>
<H2><A NAME="e_lt_argse_gt_">&lt;%args&gt;

</A></H2>
xxx contains a list of argument declarations, one per line. Each
declaration contains a type character ($, @, or %), a name, and optionally
'=&gt;' followed by a default value. The default value must be a valid Perl
expression of matching type (scalar, list, hash). Each declaration may end
with a comment marked by '#'. See <A HREF="#accessing_parameters">Accessing Parameters</A> above for usage and examples.


<P>

<P>
<HR>
<H2><A NAME="e_lt_oncee_gt_">&lt;%once&gt;

</A></H2>
This code executes once when the component is loaded. Unlike the other
sections, its scope is above the component subroutine instead of inside it.
Useful for declaring persistent component-scoped lexical variables
(especially objects that are expensive to create), declaring subroutines
(both named and anonymous), and initializing state.


<P>

This code does not run inside a request context. You cannot call
components, use any mc_ commands, or access <CODE>$REQ</CODE> from this
section.


<P>

Normally this code will execute individually from every HTTP child that
uses the component. However, if the component is preloaded, this code will
only execute once in the parent. Unless you have total control over what
components will be preloaded, it is safest to avoid initializing variables
that can't survive a <CODE>fork(),</CODE> e.g. DBI handles. Use the
following trick to initialize such variables in the &lt;%init&gt; section:


<P>

<PRE>    &lt;%once&gt;
    my $dbh;    # declare but don't assign
    ...
    &lt;/%once&gt;
</PRE>

<P>

<PRE>    &lt;%init&gt;
    if ($REQ-&gt;comp-&gt;first_time) {
        $dbh = DBI::connect ...
    }
    ...
    &lt;/%init&gt;
</PRE>

<P>

<P>
<HR>
<H2><A NAME="e_lt_def_i_name_e_gt_">&lt;%def <EM>name</EM>&gt;

</A></H2>
Each instance of this section creates a subcomponent embedded inside the
current component. Inside you may place anything that a regular component
contains: embedded Perl, <CODE>&lt;%init&gt;</CODE> and <CODE>&lt;%args&gt;</CODE> sections, etc. (The only prohibited tag is another <CODE>&lt;%def&gt;</CODE>, but this will be supported eventually).


<P>

The <EM>name</EM> consists of characters in the set <CODE>[A-Za-z0-9._-]</CODE>. To call a subcomponent simply use its name in &lt;&amp; &amp;&gt; or <A HREF="././Commands.html#item_mc_comp">mc_comp</A>. A subcomponent can only be seen from its parent component.


<P>

If you define a subcomponent with the same name as a file-based component
in the current directory, the subcomponent takes precedence. You would need
to use an absolute path to call the file-based component. To avoid this
situation and for general clarity, we recommend that you pick a unique way
to name all of your subcomponents that is unlikely to interfere with
file-based components. The author prefers to start subcomponent names with
``.''.


<P>

While inside a subcomponent, you may use absolute or relative paths to call
file-based components and also call any of your ``sibling'' subcomponents.


<P>

The scope of a subcomponent is outside the parent component subroutine, so
you cannot refer to arguments or <CODE>my</CODE> variables declared in the parent component. However a subcomponent can
declare its own <CODE>&lt;%args&gt;</CODE>
section and have relevant values passed in.


<P>

In the following example, we create a ``.link'' subcomponent to produce a
standardized hyperlink:


<P>

<PRE>    &lt;%def .link&gt;
    &lt;font size=&quot;4&quot; face=&quot;Verdana,Arial,Helvetica&quot;&gt;
    &lt;a href=&quot;http://www.&lt;% $site %&gt;.com&quot;&gt;&lt;% $label %&gt;&lt;/a&gt;
    &lt;/font&gt;&lt;br&gt;
    &lt;%args&gt;
    $site
    $label=&gt;ucfirst($site)
    &lt;/%args&gt;
    &lt;/%def&gt;
    
    Visit these sites:
    &lt;ul&gt;
    &lt;li&gt;&lt;&amp; .link, site=&gt;'yahoo' &amp;&gt;&lt;br&gt;
    &lt;li&gt;&lt;&amp; .link, site=&gt;'cmp', label=&gt;'CMP Media' &amp;&gt;&lt;br&gt;
    &lt;li&gt;&lt;&amp; .link, site=&gt;'excite' &amp;&gt;
    &lt;/ul&gt;
</PRE>

<P>

<P>
<HR>
<H2><A NAME="e_lt_filtere_gt_">&lt;%filter&gt;

</A></H2>
This section allows you to filter the output of the component through an
arbitrary block of code. Upon entry to this code, <CODE>$_</CODE> contains
the component output, and you are expected to modify it in place. See the <A HREF="#filtering">FILTERING</A> section for usage and examples.


<P>

<P>
<HR>
<H2><A NAME="e_lt_doce_gt_">&lt;%doc&gt;

</A></H2>
Text in this section is treated as a comment and ignored. Most useful for a
component's main documentation. One can easily write a program to sift
through a set of components and pull out their &lt;%doc&gt; blocks to form
a reference page.


<P>

Can also be used for in-line comments, though it is an admittedly
cumbersome comment marker. Another option is '%#':


<P>

<PRE>    %# this is a comment
</PRE>

<P>

These comments differ from HTML comments in that they do not appear in the
HTML.


<P>

<P>
<HR>
<H2><A NAME="e_lt_texte_gt_">&lt;%text&gt;

</A></H2>
Turns off processing of Mason syntax; text is passed through unmodified.
Useful, for example, when documenting Mason itself from a component:


<P>

<PRE>    &lt;%text&gt;
    % This is an example of a Perl line.
    &lt;% This is an example of an expression block. %&gt;
    &lt;/%text&gt;
</PRE>

<P>

This works for almost everything, but doesn't let you output &lt;/%text&gt; itself! When all else fails, use <A HREF="././Commands.html#item_mc_out">mc_out()</A>:


<P>

<PRE>    %mc_out('The tags are &lt;%text&gt; and &lt;/%text&gt;.');
</PRE>

<P>

<P>
<HR>
<H2><A NAME="_at_end_of_line">\ at end of line

</A></H2>
A \ suppresses the newline before %-lines and section tags. In HTML
components, this is mostly useful for fixed width areas like &lt;PRE&gt;
tags, since browsers ignore white space for the most part. An example:


<P>

<PRE>    &lt;PRE&gt;
    foo
    %if ($b == 2) {
    bar
    %}
    baz
    &lt;/PRE&gt;
</PRE>

<P>

outputs


<P>

<PRE>    foo
    bar
    baz
</PRE>

<P>

because of the newlines on lines 1 and 3. (Lines 2 and 4 do not generate a
newline because the entire line is taken by Perl.) To suppress the
newlines:


<P>

<PRE>    &lt;PRE&gt;
    foo\
    %if ($b == 2) {
    bar\
    %}
    baz
    &lt;/PRE&gt;
</PRE>

<P>

which prints


<P>

<PRE>    foobarbaz
</PRE>

<P>

The backslash has no special meaning outside this context. In particular,
you cannot use it to escape a newline before a plain text line.


<P>

<P>
<HR>
<H1><A NAME="data_caching">DATA CACHING

</A></H1>
Mason's <A HREF="././Commands.html#item_mc_cache">mc_cache()</A> and <A HREF="././Commands.html#item_mc_cache_self">mc_cache_self()</A> commands let components save and retrieve the results of computation for
improved performance. Anything may be cached, from a block of HTML to a
complex data structure.


<P>

Each component gets a private data cache. Except under special
circumstances, one component does not access another component's cache.
Each cached value may be set to expire under certain conditions or at a
certain time.


<P>

To use data caching, your Mason installation must be configured with a good
DBM package like Berkeley DB (DB_File) or GDBM. See
<STRONG><A HREF="././Admin.html#">HTML::Mason::Admin</A></STRONG> for more information.


<P>

<P>
<HR>
<H2><A NAME="basic_usage">Basic Usage

</A></H2>
Here's the typical usage of mc_cache:


<P>

<PRE>  my $result = mc_cache(action=&gt;'retrieve');
  if (!defined($result)) {
      ... compute $result&gt; ...
      mc_cache(action=&gt;'store', value=&gt;$result);
  }
</PRE>

<P>

The first mc_cache call attempts to retrieve this component's cache value.
If the value is available it is placed in <CODE>$result</CODE>. If the value is not available, <CODE>$result</CODE> is computed and stored in the cache by the second mc_cache call.


<P>

The default action for mc_cache is 'retrieve', so the first line can be
written as


<P>

<PRE>  my $result = mc_cache();
</PRE>

<P>

<P>
<HR>
<H2><A NAME="multiple_keys_values">Multiple Keys/Values

</A></H2>
A cache file can store multiple keys and values. A value can be a scalar,
list reference, or hash reference:


<P>

<PRE>  mc_cache(action=&gt;'store',key=&gt;'name',value=&gt;$name);
  mc_cache(action=&gt;'store',key=&gt;'friends',value=&gt;\@lst);
  mc_cache(action=&gt;'store',key=&gt;'map',value=&gt;\%hsh);
</PRE>

<P>

The key defaults to 'main' when unspecified, as in the first example above.


<P>

Mason uses the <STRONG>MLDBM</STRONG> package to store and retrieve from its cache files, meaning that Mason can
cache arbitrarily deep data structures composed of lists, hashes, and
simple scalars.


<P>

<P>
<HR>
<H2><A NAME="expiration">Expiration

</A></H2>
Typical cache items have a useful lifetime after which they must expire.
Mason supports three types of expiration:


<P>

<DL>
<DT><STRONG><A NAME="item_By_Time">By Time

</A></STRONG><DD>
(e.g. the item expires in an hour, or at midnight). To expire an item by
time, pass one of these options to the 'store' action.


<P>

<EM>expire_at</EM>: takes an absolute expiration time, in Perl <CODE>time()</CODE> format
(number of seconds since the epoch)


<P>

<EM>expire_in</EM>: takes a relative expiration time of the form ``&lt;num&gt;&lt;unit&gt;'',
where &lt;num&gt; is a positive number and &lt;unit&gt; is one of seconds,
minutes, hours, days, or weeks, or any abbreviation thereof. E.g.
``10min'', ``1hour''.


<P>

<EM>expire_next</EM>: takes a string, either 'hour' or 'day'. It indicates an expiration time
at the top of the next hour or day.


<P>

Examples:


<P>

<PRE>    mc_cache(action=&gt;'store', expire_in=&gt;'2 hours');
    mc_cache(action=&gt;'store', expire_next=&gt;'hour');
</PRE>

<P>

<DT><STRONG><A NAME="item_By_Condition">By Condition

</A></STRONG><DD>
(e.g. the item expires if a certain file or database table changes). To
expire an item based on events rather than current time, pass the
'expire_if' option to the 'retrieve' action.


<P>

<EM>expire_if</EM>: calls a given anonymous subroutine and expires if the subroutine returns
a non-zero value. The subroutine is called with one parameter, the time
when the cache value was last written.


<P>

Example:


<P>

<PRE>    # expire the cache if 'myfile' is newer
    mc_cache(action =&gt; 'retrieve',
          expire_if =&gt; sub { [stat 'myfile']-&gt;[9] &gt; $_[0] });
</PRE>

<P>

<DT><STRONG><A NAME="item_By_Explicit_Action">By Explicit Action

</A></STRONG><DD>
(e.g. a shell command or web interface is responsible for explicitly
expiring the item) To expire an item from a Perl script, for any component,
use <STRONG>access_data_cache</STRONG>. It takes the same arguments as mc_cache plus one additional argument,
cache_file. See the administration manual for details on where cache files
are stored and how they are named.


<P>

<PRE>    use HTML::Mason::Utils 'access_data_cache';
    access_data_cache (cache_file=&gt;'/usr/local/mason/cache/foo::bar',
                       action=&gt;'expire' [, key=&gt;'fookey']);
</PRE>

<P>

The 'expire' action can also take multiple keys (as a list reference); this
can be used in conjunction with the 'keys' action to expire all keys
matching a particular pattern.


<P>

<PRE>    use HTML::Mason::Utils 'access_data_cache';
    my @keys = access_data_cache (cache_file=&gt;'/usr/local/mason/cache/foo::bar',
                                  action=&gt;'keys');
    access_data_cache (cache_file=&gt;'/usr/local/mason/cache/foo::bar',
                       action=&gt;'expire', key=&gt;[grep(/^sales/,@keys)]);
</PRE>

<P>

</DL>
<P>
<HR>
<H2><A NAME="busy_locks">Busy Locks

</A></H2>
The code shown in ``Basic Usage'' above,


<P>

<PRE>  my $result = mc_cache(action=&gt;'retrieve');
  if (!defined($result)) {
      ... compute $result&gt; ...
      mc_cache(action=&gt;'store', value=&gt;$result);
  }
</PRE>

<P>

can suffer from a kind of race condition for caches that are accessed
frequently and take a long time to recompute.


<P>

Suppose that a particular cache value is accessed five times a second and
takes three seconds to recompute. When the cache expires, the first process
comes in, sees that it is expired, and starts to recompute the value. The
second process comes in and does the same thing. This sequence continues
until the first process finishes and stores the new value. On average, the
value will be recomputed and written to the cache 15 times!


<P>

The solution here is to have the first process notify the others that it
has started recomputing. This can be accomplished with the busy_lock flag:


<P>

<PRE>        mc_cache(action=&gt;'retrieve',busy_lock=&gt;'10sec',...);
</PRE>

<P>

With this flag, the first process sets a lock in the cache that effectively
says ``I'm busy recomputing his value, don't bother.'' Subsequent processes
see the lock and return the old value. The lock is good for 10 seconds (in
this case) and is ignored after that. Thus the time value you pass to
busy_lock indicates how long you're willing to allow this component to use
an expired cache value.


<P>

Would some of your caches would benefit from busy locks? One way to find
out is to turn on cache logging in the Mason system logs. If you see large
clusters of writes to the same cache in a short time span, then you might
want to use busy locks when writing to that cache.


<P>

<P>
<HR>
<H2><A NAME="keeping_in_memory">Keeping In Memory

</A></H2>
The keep_in_memory flag indicates that the cache value should be kept in
memory after it is stored or retrieved. Since every child process will
store its own copy, this flag should be used only for small, frequently
retrieved cache values. If used, this flag should be passed to both the
store and retrieve commands.


<P>

<P>
<HR>
<H2><A NAME="caching_all_output">Caching All Output 

</A></H2>
Occasionally you will need to cache the complete output of a component. One
way to accomplish this is to replace the component with a placeholder that
simply calls the component, then caches and prints the result. For example,
if the component were named ``foo'', we might rename it to ``foo_main'' and
put this component in its place:


<P>

<PRE>    &lt;% $foo_out %&gt;
    &lt;%init&gt;
        my $foo_out;
        if (!defined ($foo_out = mc_cache())) {
            mc_comp('foo_main', STORE=&gt;\$foo_out);
            mc_cache(action=&gt;'store',
                  expire_in=&gt;'3 hours', value=&gt;$foo_out);
        }
    &lt;/%init&gt;
</PRE>

<P>

This works, but is cumbersome. Mason offers a better shortcut: the
<STRONG>mc_cache_self()</STRONG> command that lets a component cache it's own output and eliminates the need
for a dummy component. It is typically used right at the top of a <CODE>&lt;%init%&gt;</CODE> section:


<P>

<PRE>    &lt;%init&gt;
        return if mc_cache_self(expire_in=&gt;'3 hours'[, key=&gt;'fookey']);
        ... &lt;rest of init&gt; ...
    &lt;/%init&gt;
</PRE>

<P>

<STRONG>mc_cache_self</STRONG> is built on top of <STRONG>mc_cache</STRONG>, so it inherits all the expiration options described earlier.


<P>

<P>
<HR>
<H2><A NAME="guarantees_or_lack_thereof_">Guarantees (or lack thereof)

</A></H2>
Mason will make a best effort to cache data until it expires, but will not
guarantee it. The data cache is not a permanent reliable store in itself;
you should not place in the cache critical data (e.g. user session
information) that cannot be regenerated from another source such as a
database. You should write your code as if the cache might disappear at any
time. In particular,


<P>

o If the 'store' action cannot get a write lock on the cache, it simply
fails quietly.


<P>

o If the 'retrieve' action cannot get a shared lock on the cache, it simply
fails quietly. (This is much more rare.)


<P>

o Your Mason administrator will be required to remove cache files
periodically when they get too large; this can happen any time.


<P>

On the other hand, expiration in its various forms is guaranteed, because
Mason does not want you to rely on bad data to generate your content. If
you use the 'expire' action and Mason cannot get a write lock, it will
repeat the attempt several times and finally die with an error.


<P>

<P>
<HR>
<H1><A NAME="filtering">FILTERING

</A></H1>
This section describes several ways to apply filtering functions over the
results of the current component. By separating out and hiding a filter
that, say, changes HTML in a complex way, we allow non-programmers to work
in a cleaner HTML environment.


<P>

<P>
<HR>
<H2><A NAME="_lt_filter_gt_section">&lt;%filter&gt; section

</A></H2>
The &lt;%filter&gt; section allows you to arbitrarily filter the output of
the current component. Upon entry to this code, <CODE>$_</CODE> contains
the component output, and you are expected to modify it in place. The code
has access to component arguments and can invoke subroutines, call other
components, etc.


<P>

This simple filter converts the component output to UPPERCASE:


<P>

<PRE>    &lt;%filter&gt;
    tr/a-z/A-Z/
    &lt;/%filter&gt;
</PRE>

<P>

The following navigation bar uses a filter to ``unlink'' and highlight the
item corresponding to the current page:


<P>

<PRE>    &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt; | &lt;a href=&quot;/products/&quot;&gt;Products&lt;/a&gt; | 
    &lt;a href=&quot;/bg.html&quot;&gt;Background&lt;/a&gt; | &lt;a href=&quot;/finance/&quot;&gt;Financials&lt;/a&gt; | 
    &lt;a href=&quot;/support/&quot;&gt;Tech Support&lt;/a&gt; | &lt;a href=&quot;/contact.html&quot;&gt;Contact Us&lt;/a&gt;
</PRE>

<P>

<PRE>    &lt;%filter&gt;
    my $uri = $r-&gt;uri;
    s{&lt;a href=&quot;$uri/?&quot;&gt;(.*?)&lt;/a&gt;} {&lt;b&gt;$1&lt;/b&gt;}i;
    &lt;/%filter&gt;
</PRE>

<P>

This allows a designer to code such a navigation bar intuitively without <CODE>if</CODE> statements surrounding each link! Note that the regular expression need not
be very robust as long as you have control over what will appear in the
body.


<P>

<P>
<HR>
<H2><A NAME="mc_call_self_command">mc_call_self command

</A></H2>
This command allows you to filter both the output and the return value of
the current component. It is fairly advanced; for most purposes the
<CODE>&lt;%filter&gt;</CODE> tag above will be sufficient and simpler.


<P>

mc_call_self takes two arguments. The first is a scalar reference and will
be populated with the component output. The second is either a scalar or
list reference and will be populated with the component return value; the
type of reference determines whether the component will be called in scalar
or list context. Both of these arguments are optional; you may pass undef
if you don't care about one of them.


<P>

mc_call_self acts like a <CODE>fork()</CODE> in the sense that it will
return twice with different values. When it returns 0, you allow control to
pass through to the rest of your component. When it returns 1, that means
the component has finished and you can begin filtering the output and/or
return value. (Don't worry, it doesn't really do a fork! See next section
for explanation.)


<P>

The following examples would generally appear at the top of a <CODE>&lt;%init&gt;</CODE>
section. Here is a no-op mc_call_self that leaves the output and return
value untouched:


<P>

<PRE>    if (mc_call_self(my \$output, my \$retval)) {  # assumes Perl 5.005 or greater
        mc_out($output);
        return $retval;
    }
</PRE>

<P>

Here is a simple output filter that makes the output all uppercase, just
like the <CODE>&lt;%filter&gt;</CODE> example above. Note that we ignore both the original and the final return
value.


<P>

<PRE>    if (mc_call_self(my \$output, undef)) {
        mc_out(uc($output));
        return;
    }
</PRE>

<P>

mc_call_self can even convert output to a return value or vice versa. In
the next component we provide a nice friendly format for non-programmers to
represent data with, and use a filter to construct and return a
corresponding Perl data structure from it:


<P>

<PRE>    # id        lastname        firstname
    59286       Sherman         Karen
    31776       Dawson          Robert
    29482       Lee             Brenda
    ...
</PRE>

<P>

<PRE>    &lt;%perl_init&gt;
    if (mc_call_self(my \$output, undef)) {
        foreach (split(&quot;\n&quot;,$output)) {
            next if /^#/ || !/\S/;
            my @vals = split(/\s+/);
            push(@people,{id=&gt;$vals[0],last=&gt;$vals[1],first=&gt;$vals[2]});
        }
        return @people;
    }
    &lt;/%perl_init&gt;
</PRE>

<P>

Now we can get a list of hashes directly from this component.    


<P>

<P>
<HR>
<H2><A NAME="how_filtering_works">How filtering works

</A></H2>
mc_call_self (and <CODE>&lt;%filter&gt;</CODE>, which is built on it) uses a bit of magic to accomplish everything in one
line. If you're curious, here's how it works:


<P>

o A component foo calls mc_call_self for the first time.


<P>

o mc_call_self sets an internal flag and calls foo again recursively, with
a STORE option to capture its content into a buffer.


<P>

o foo again calls mc_call_self which, seeing the flag, returns 0
immediately.


<P>

o foo goes about its business and generates content into the mc_call_self
buffer.


<P>

o When control is returned to mc_call_self, it places the content and
return value in the references provided, and returns 1.


<P>

<P>
<HR>
<H1><A NAME="accessing_server_internals">ACCESSING SERVER INTERNALS

</A></H1>
Mason makes the powerful <CODE>$r</CODE> Apache request object available as a global in all components, granting
access to a variety of server internals, HTTP request data, and server API
methods.


<P>

<CODE>$r</CODE> is fully described in Apache.pod -- here is a sampling of methods useful to
component developers:


<P>

<PRE>    $r-&gt;uri             # the HTTP request URI
    $r-&gt;header_in(..)   # get the named HTTP header line
    $r-&gt;content_type    # set or retrieve content-type
    $r-&gt;header_out(..)  # set or retrieve an outgoing header
</PRE>

<P>

<PRE>    $r-&gt;content         # don't use this one! (see Tips and Traps)
</PRE>

<P>

<P>
<HR>
<H1><A NAME="sending_http_headers">SENDING HTTP HEADERS

</A></H1>
Mason sends a standard HTTP header with content type text/html when it
reaches the primary HTML section of a component (after any
<CODE>&lt;%init&gt;</CODE> section).


<P>

That means if you want to send your own HTTP header, you have to do it in
the <CODE>&lt;%init%&gt;</CODE> section. You send headers with Apache commands headers_out and
send_http_header.


<P>

To prevent Mason from sending out the default header, call
<A HREF="././Commands.html#item_mc_suppress_http_header">mc_suppress_http_header(1)</A>. You only need to do this if you are going to call a component before
sending your header. Here's an example:


<P>

<PRE>    &lt;%init&gt;
    ...
    mc_suppress_http_header(1);   # necessary because of next line
    my $registered = mc_comp('isUserRegistered');
    if (!$registered) {
         mc_comp('/shared/http/redirect',url=&gt;'/registerScreen');
    }
    ...
    &lt;/%init&gt;
</PRE>

<P>

The component isUserRegistered returns 0 or 1 indicating whether the user
has registered (e.g. by looking for a cookie). If the result is 0, we use
an HTTP redirect to go to the registration screen. Mason would normally
send the default header upon reaching the primary section of
isUserRegistered - that is why we must call mc_suppress_http_header.


<P>

To cancel header suppression, call <CODE>mc_suppress_http_header(0).</CODE> 


<P>

<P>
<HR>
<H1><A NAME="component_and_request_objects">COMPONENT AND REQUEST OBJECTS

</A></H1>
In version 0.7, the Mason core was rewritten in a more object-oriented
manner with two additional classes, <CODE>Request</CODE> and <CODE>Component</CODE>. Besides contributing to a cleaner, more scalable system, the new APIs
provide developers with increased control and introspection over Mason's
inner workings.


<P>

<CODE>HTML::Mason::Request</CODE> allows you to query the state of, and perform actions on, the current
request from inside a component. It provides for Mason what Apache::Request
provides for the Apache server. Inside a component you access the current
request object via the global <CODE>$REQ</CODE>. From this one object you can:


<P>

<UL>
<LI><STRONG></STRONG>
get handles on the associated Parser, Interpreter, and ApacheHandler
objects


<P>

<LI><STRONG></STRONG>
access the current component and the stack of previous components, as well
as their arguments


<P>

<LI><STRONG></STRONG>
fetch and call new components


<P>

</UL>
<CODE>HTML::Mason::Component</CODE> is the class where Mason keeps all components loaded into memory. Once
you've gotten a component object (generally from one of the Request
methods), you can:


<P>

<UL>
<LI><STRONG></STRONG>
get its source file, object file, and cache file pathnames


<P>

<LI><STRONG></STRONG>
query about its declared arguments and subcomponents


<P>

<LI><STRONG></STRONG>
call the component by using it inside &lt;&amp; &amp;&gt; or <A HREF="././Commands.html#item_mc_comp">mc_comp</A>




<P>

</UL>
See the <A HREF="././Request.html#">HTML::Mason::Request</A> and <A HREF="././Component.html#">HTML::Mason::Component</A>
reference pages for more details.


<P>

<P>
<HR>
<H1><A NAME="using_the_perl_debugger">USING THE PERL DEBUGGER

</A></H1>
The Perl debugger is an indispensable tool for identifying and fixing bugs
in Perl programs. Unfortunately, in a mod_perl environment one is normally
unable to use the debugger since programs are run from a browser. Mason
removes this limitation by optionally creating a <EM>debug
file</EM> for each page request, allowing the request to be replayed from the command
line or Perl debugger.


<P>

Note: in early 1999 a new module, Apache::DB, was released that makes it
substantially easier to use the Perl debugger directly in conjunction with
a real Apache server. Since this mechanism is still new, we continue to
support Mason debug files, and there may be reasons to prefer Mason's
method (e.g. no need to start another Apache server). However we
acknowledge that Apache::DB may eventually eliminate the need for debug
files. For now we encourage you to try both methods and see which one works
best.


<P>

<P>
<HR>
<H2><A NAME="using_debug_files">Using debug files

</A></H2>
Here is a typical sequence for debugging a Mason page:


<P>

<OL>
<LI><STRONG><A NAME="item_Find_the_debug_file_"> Find the debug file:

</A></STRONG>
When Mason is running in debug mode, requests generate ``debug files'',
cycling through filenames ``1'' through ``20''. To find a request's debug
file, simply do a ``View Source'' in your browser after the request and
look for a comment like this at the very top:


<P>

<PRE>    &lt;!--
    Debug file is '3'.
    Full debug path is '/usr/local/mason/debug/anon/3'.
    --&gt;
</PRE>

<P>

<LI><STRONG><A NAME="item_Run_the_debug_file_"> Run the debug file:

</A></STRONG>
Debug files basically contain two things: a copy of the entire HTTP request
(serialized with <STRONG>Data::Dumper</STRONG>), and all the plumbing needed to route that request through Mason. In
other words, if you simply run the debug file like this:


<P>

<PRE>    perl /usr/local/mason/debug/anon/3
</PRE>

<P>

you should see the HTTP headers and content that the component would
normally send to the browser.


<P>

<LI><STRONG><A NAME="item_Debug_the_debug_file_"> Debug the debug file:

</A></STRONG>
Now you merely add a <CODE>-d</CODE> option to run the debug file in Perl's debugger -- at which point you have
to deal the problem of anonymous subroutines.


<P>

Mason compiles components down to anonymous subroutines which are not
easily breakpoint'able (Perl prefers line numbers or named subroutines).
Therefore, immediately before each component call, Mason calls a nonce
subroutine called <CODE>debug_hook</CODE> just so you can breakpoint it like this:


<P>

<PRE>    b HTML::Mason::Request::debug_hook
</PRE>

<P>

debug_hook is called with the component name as the second parameter so
that you can also breakpoint specific components using a conditional on
$_[1]:


<P>

<PRE>    b HTML::Mason::Request::debug_hook $_[1] =~ /component name/
</PRE>

<P>

You can avoid all that typing by adding the following to your ~/.perldb
file:


<P>

<PRE>    # Perl debugger aliases for Mason
    $DB::alias{mb} = 's/^mb\b/b HTML::Mason::Request::debug_hook/';
</PRE>

<P>

which reduces the previous examples to just: 


<P>

<PRE>    mb
    mb $_[1] =~ /component name/
</PRE>

<P>

</OL>
The use of debug files opens lots of other debugging options. For instance,
you can read a debug file into the Emacs editor, with its nifty interface
to Perl's debugger. This allows you to set break points visually or (in
trace mode) watch a cursor bounce through your code in single-step or
continue mode.


<P>

<P>
<HR>
<H2><A NAME="specifying_when_to_create_debug_">Specifying when to create debug files

</A></H2>
Details about configuring debug mode can be found in
<STRONG><A HREF="././Admin.html#">HTML::Mason::Admin</A></STRONG>. In particular, the administrator must decide which of three debugging
modes to activate:


<P>

<STRONG>never</STRONG> (no debug files)


<P>

<STRONG>always</STRONG> (create debug files for each request)


<P>

<STRONG>error</STRONG> (only generate a debug file when an error occurs)


<P>

<P>
<HR>
<H2><A NAME="how_debug_files_work">How debug files work

</A></H2>
To create a debug file, Mason calls almost every one of the mod_perl API
methods (<CODE>$r-&gt;xxx</CODE>), trapping its result in a hash. That hash is then serialized by
Data::Dumper and output into a new debug file along with some surrounding
code.


<P>

When the debug file is executed, a new object is created of the class
``HTML::Mason::FakeApache'', passing the saved hash as initialization. The
FakeApache object acts as a fake <CODE>$r</CODE>, responding to each method by getting or setting data in its hash. For
most purposes it is indistinguishable from the original <CODE>$r</CODE> except that print methods go to standard output. The debug file then
executes your <CODE>handler()</CODE>
function with the simulated <CODE>$r</CODE>.


<P>

<P>
<HR>
<H2><A NAME="when_debug_files_don_t_work">When debug files don't work

</A></H2>
The vast majority of mod_perl API methods are simple get/set functions
(e.g. <CODE>$r-&gt;uri</CODE>, <CODE>$r-&gt;content_type</CODE>) which are easy to simulate. Many pages only make use of these methods and
can be successfully simulated in debug mode.


<P>

However, a few methods perform tasks requiring the presence of a true
Apache server. These cannot be properly simulated. Some, such as
<CODE>log_error</CODE> and <CODE>send_cgi_header</CODE>, are generally tangential to the debugging effort; for these Mason simply
returns without doing anything and hopes for the best. Others, such as <CODE>internal_redirect</CODE>
and <CODE>lookup_uri</CODE>, perform such integral functions that they cannot be ignored, and for
these FakeApache aborts with an error. This category includes any method
call expected to return an Apache::Table object.


<P>

In addition, FakeApache is playing something of a catch-up game: every time
a new mod_perl release comes out with new API methods, those methods will
not be recognized by FakeApache until it is updated in the next Mason
release.


<P>

The combination of these problems and the existence of the new Apache::DB
package may eventually lead us to stop further work on FakeApache/debug
files. For now, though, we'll continue to support them as best we can.


<P>

<P>
<HR>
<H1><A NAME="using_the_perl_profiler">USING THE PERL PROFILER

</A></H1>
Debug files, mentioned in the previous section, can be used in conjunction
with Devel::DProf to profile a web request.


<P>

To use profiling, pass the <CODE>-p</CODE> flag to the debug file:


<P>

<PRE>    % ./3 -p
</PRE>

<P>

This executes the debug file under Devel::DProf and, for convenience, runs
dprofpp. If you wish you can rerun dprofpp with your choice of options.


<P>

Because components are implemented as anonymous subroutines, any time spent
in components would normally be reported under an unreadable label like
<CODE>CODE(0xb6cbc).</CODE> To remedy this, the <CODE>-p</CODE> flag automatically adjusts the tmon.out file so that components are
reported by their component paths.


<P>

Much of the time spent in a typical debug file is initialization, such as
loading Mason and other Perl modules. The effects of initialization can
swamp profile results and obscure the time actually spent in components.
One remedy is to run multiple iterations of the request inside the debug
file, thus reducing the influence of initialization time. Pass the number
of desired iterations via the <CODE>-r</CODE>
flag:


<P>

<PRE>    % ./3 -p -r20
</PRE>

<P>

Currently there are no special provisions for other profiling modules such
as Devel::SmallProf. You can try simply:


<P>

<PRE>    % perl -d:SmallProf ./3 -r20
</PRE>

<P>

However, this crashes on our Unix system -- apparently some bad interaction
between Mason and SmallProf -- so it is unsupported for now.


<P>

<P>
<HR>
<H1><A NAME="the_previewer">THE PREVIEWER

</A></H1>
Mason comes with a web-based debugging utility that lets you test your
components by throwing fake requests at them. Adjustable parameters
include: UserAgent, Time, HTTP Referer, O/S and so on. For example, imagine
a component whose color scheme is supposed to change each morning, noon,
and night. Using the Previewer, it would be simple to set the perceived
time forward 1,5 or 8 hours to test the component at various times of day.


<P>

The Previewer also provides a debug trace of a page, showing all components
being called and indicating the portion of HTML each component is
responsible for. For pages constructed from more than a few components,
these traces are quite useful for finding the component that is outputting
a particular piece of HTML.


<P>

Your administrator will give you the main Previewer URL, and a set of
preview ports that you will use to view your site under various conditions.
For the purpose of this discussion we'll assume the Previewer is up and
working, that the Previewer URL is <A
HREF="http://www.yoursite.com/preview,">http://www.yoursite.com/preview,</A>
and the preview ports are 3001 to 3005.


<P>

Take a look at the main Previewer page. The top part contains the most
frequently used options, such as time and display mode. The middle part
contains a table of your saved configurations; if this is your first time
using the Previewer, it will be empty. The bottom part contains less
frequently used options, such as setting the user agent and referer.


<P>

Try clicking ``Save''. This will save the displayed settings under the
chosen preview port, say 3001, and redraw the page. Under ``Saved Port
Settings'', you should see a single row showing this configuration. Your
configurations are saved permanently in a file. If a username/password is
required to access the Previewer, then each user has his/her own
configuration file.


<P>

The ``View'' button should display your site's home page. If not, then the
Previewer may not be set up correctly; contact your administrator or see
the Administrator's Manual.


<P>

Go back to the main Previewer page, change the display mode from ``HTML''
to ``debug'', change the preview port to 3002, and click ``Save'' again.
You should now see a second saved configuration.


<P>

Click ``View''. This time instead of seeing the home page as HTML, you'll
get a debug trace with several sections. The first section shows a numbered
hierarchy of components used to generate this page. The second section is
the HTML source, with each line annotated on the left with the number of
the component that generated it. Try clicking on the numbers in the first
section; this brings you to the place in the second section where that
component first appears. If there's a particular piece of HTML you want to
change on a page, searching in the annotated source will let you quickly
determine which component is responsible.


<P>

The final section of the debug page shows input and output HTTP headers.
Note that some of these are simulated due to your Previewer settings. For
example, if you specified a particular user agent in your Previewer
configuration, then the User-Agent header is simulated; otherwise it
reflects your actual browser.


<P>

<P>
<HR>
<H1><A NAME="tips_and_traps">TIPS AND TRAPS

</A></H1>
<DL>
<DT><STRONG><A NAME="item_Do_not_call_r_content_or_new_">Do not call $r-&gt;content or ''new CGI``

</A></STRONG><DD>
Mason calls <CODE>$r-&gt;content</CODE> itself to read request input, emptying the input buffer and leaving a trap
for the unwary: subsequent calls to <CODE>$r-&gt;content</CODE> hang the server. This is a mod_perl ``feature'' that may be fixed in an
upcoming release. Instead you can access the request input via


<P>

<PRE>  $REQ-&gt;http_input
</PRE>

<P>

For the same reason you should not create a CGI object like


<P>

<PRE>  my $query = new CGI;
</PRE>

<P>

when handling a POST; the CGI module will try to reread request input and
hang. Instead, create an empty object:


<P>

<PRE>  my $query = new CGI (&quot;&quot;);
</PRE>

<P>

such an object can still be used for all of CGI's useful HTML output
functions. Or, if you really want to use CGI's input functions, initialize
the object from %ARGS:


<P>

<PRE>  my $query = new CGI (\%ARGS);
</PRE>

<P>

<DT><STRONG><A NAME="item_Separate_Perl_from_HTML">Separate Perl from HTML

</A></STRONG><DD>
In our experience, the most readable components, especially for
non-programmer designers and editors, contain full HTML in one continuous
block at the top with simple substitutions for dynamic elements
(&lt;%$name%&gt;, &lt;%$salary%&gt;) but no distracting blocks of Perl
code. At the bottom an &lt;%init&gt; block sets up the substitution
variables -- getting <CODE>$name</CODE> from the database, calculating
$salary, etc. This organization allows non-programmers to work with the
HTML without getting distracted or discouraged by Perl code.


<P>

This technique does sacrifice some performance for readability.


<P>

</DL>
<P>
<HR>
<H1><A NAME="author">AUTHOR

</A></H1>
Jonathan Swartz, <A
HREF="MAILTO:swartz@transbay.net">swartz@transbay.net</A>


<P>

<P>
<HR>
<H1><A NAME="see_also">SEE ALSO

</A></H1>
<A HREF="././Mason.html#">HTML::Mason</A>,
<A HREF="././Commands.html#">HTML::Mason::Commands</A>




<P>

</DL>
    </BODY>

    </HTML>
