<HTML>
<HEAD>
<TITLE>HTML::Mason::Interp - Mason Component Interpreter</TITLE>
<LINK REV="made" HREF="mailto:perl@packages.debian.org">
</HEAD>

<BODY>

<A NAME="__index__"></A>
<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#name">NAME</A></LI>
	<LI><A HREF="#synopsis">SYNOPSIS</A></LI>
	<LI><A HREF="#description">DESCRIPTION</A></LI>
	<LI><A HREF="#parameters for new() constructor">PARAMETERS FOR <CODE>new()</CODE> CONSTRUCTOR</A></LI>
	<LI><A HREF="#accessor methods">ACCESSOR METHODS</A></LI>
	<LI><A HREF="#other methods">OTHER METHODS</A></LI>
	<LI><A HREF="#see also">SEE ALSO</A></LI>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="name">NAME</A></H1>
<P>HTML::Mason::Interp - Mason Component Interpreter</P>
<P>
<HR>
<H1><A NAME="synopsis">SYNOPSIS</A></H1>
<PRE>
    my $i = new HTML::Mason::Interp (data_dir=&gt;'/usr/local/mason',
                                     comp_root=&gt;'/usr/local/www/htdocs/',
                                     ...other params...);</PRE>
<P>
<HR>
<H1><A NAME="description">DESCRIPTION</A></H1>
<P>Interp is the Mason workhorse, executing components and routing their
output and errors to all the right places. In a mod_perl environment,
Interp objects are handed off immediately to an ApacheHandler object
which internally calls the Interp implementation methods. In that case
the only user method is the <CODE>new()</CODE> constructor.</P>
<P>
<HR>
<H1><A NAME="parameters for new() constructor">PARAMETERS FOR <CODE>new()</CODE> CONSTRUCTOR</A></H1>
<DL>
<DT><STRONG><A NAME="item_autohandler_name">autohandler_name</A></STRONG><BR>
<DD>
File name used for autohandlers. Default is ``autohandler''.
<P></P>
<DT><STRONG><A NAME="item_autoflush">autoflush</A></STRONG><BR>
<DD>
This parameter indicates whether or not requests created by this
interpreter should have autoflush turned on or off by default.
<P></P>
<DT><STRONG><A NAME="item_code_cache_max_size">code_cache_max_size</A></STRONG><BR>
<DD>
Specifies the maximum size, in bytes, of the in-memory code cache
where components are stored. e.g.
<PRE>
    code_cache_max_size =&gt; 20*1024*1024
    code_cache_max_size =&gt; 20_000_000</PRE>
<P>Default is 10 MB. See the <A HREF="Admin.html#code cache">Code Cache section in the <EM>Admin Guide</EM></A> for further details.</P>
<P></P>
<DT><STRONG><A NAME="item_compiler">compiler</A></STRONG><BR>
<DD>
The Compiler object to associate with this Interpreter.  If none is
provided a default compiler using the
<CODE>HTML::Mason::Compiler::ToObject</CODE> and <CODE>HTML::Mason::Lexer</CODE> classes
will be created.
<P></P>
<DT><STRONG><A NAME="item_data_dir">data_dir</A></STRONG><BR>
<DD>
The Mason data directory. Mason's various data directories (obj,
cache, etc), live within the data_dir.
<P>If this parameter is not given then there are several results.  First,
Mason will not use object files, since it has no place to put them.
Second, the default caching class for the request object will be
Cache::MemoryCache instead of Cache::FileCache.</P>
<P></P>
<DT><STRONG><A NAME="item_data_cache_defaults">data_cache_defaults</A></STRONG><BR>
<DD>
A hash reference of default options to use for the <CODE>$m-&gt;cache</CODE>
command. For example, to use the Cache::MemoryCache implementation
by default,
<PRE>
    data_cache_defaults =&gt; {cache_class =&gt; 'MemoryCache'}</PRE>
<P>These settings are overriden by options given to particular
<CODE>$m-&gt;cache</CODE> calls.</P>
<P></P>
<DT><STRONG><A NAME="item_static_source">static_source</A></STRONG><BR>
<DD>
True or false, default is false. When false, Mason checks the
timestamp of the component source file each time the component is used
to see if it has changed. This provides the instant feedback for
source changes that is expected for development.  However it does
entail a file stat for each component executed.
<P>When true, Mason assumes that the component source tree is unchanging:
it will not check component source files to determine if the memory
cache or object file has expired.  This can save many file stats per
request. However, in order to get Mason to recognize a component
source change, you must remove object files and restart the server (so
as to clear the memory cache).</P>
<P>Use this feature for live sites where performance is crucial and
where updates are infrequent and well-controlled.</P>
<P></P>
<DT><STRONG><A NAME="item_ignore_warnings_expr">ignore_warnings_expr</A></STRONG><BR>
<DD>
Regular expression indicating which warnings to ignore when loading
components. Any warning that is not ignored will prevent the
component from being loaded and executed. For example:
<PRE>
    ignore_warnings_expr =&gt;
        'Global symbol.*requires explicit package'</PRE>
<P>If undef, all warnings are heeded; if '.', all warnings are ignored.</P>
<P>By default, this is set to 'Subroutine .* redefined'.  This allows you
to declare global subroutines inside &lt;%once&gt; sections and not receive
an error when the component is reloaded.</P>
<P></P>
<DT><STRONG><A NAME="item_preloads">preloads</A></STRONG><BR>
<DD>
A list of component paths, optionally with glob wildcards, to load
when the interpreter initializes. e.g.
<PRE>
    preloads =&gt; ['/foo/index.html','/bar/*.pl']</PRE>
<P>Default is the empty list.  For maximum performance, this should only
be used for components that are frequently viewed and rarely updated.
See the <A HREF="Admin.html#preloading">preloading section in the <EM>Admin Guide</EM></A> for further details.</P>
<P>As mentioned in the developer's guide, a component's <CODE>&lt;%once&gt;</CODE>
section is executed when it is loaded.  For preloaded components, this
means that this section will be executed before a Mason or Apache
request exist, so preloading a component that uses <CODE>$m</CODE> or <CODE>$r</CODE> in a
<CODE>&lt;%once&gt;</CODE> section will fail.</P>
<P></P>
<DT><STRONG><A NAME="item_resolver">resolver</A></STRONG><BR>
<DD>
The Resolver object to associate with this Interpreter.  If none is
provided, a default Resolver will be created.
<P></P>
<DT><STRONG><A NAME="item_use_object_files">use_object_files</A></STRONG><BR>
<DD>
True or false, default is true.  Specifies whether Mason creates
object files to save the results of component parsing. You may want to
turn off object files for disk space reasons, but otherwise this
should be left alone.
<P></P></DL>
<P>
<HR>
<H1><A NAME="accessor methods">ACCESSOR METHODS</A></H1>
<P>All of the above properties have standard accessor methods of the same
name. In general, no arguments retrieves the value, and one argument
sets and returns the value.  For example:</P>
<PRE>
    my $interp = new HTML::Mason::Interp (...);
    my $c = $interp-&gt;compiler;
    $interp-&gt;dhandler_name(&quot;da-handler&quot;);</PRE>
<P>The following properties can be queried but not modified: data_dir,
preloads.</P>
<P>
<HR>
<H1><A NAME="other methods">OTHER METHODS</A></H1>
<a name="item_set_global"></a><DL>
<DT><STRONG><A NAME="item_set_global">set_global ($varname, [values...])</A></STRONG><BR>
<DD>
This method sets a global to be used in components. <CODE>varname</CODE> is a
variable name, optionally preceded with a prefix (<CODE>$</CODE>, <CODE>@</CODE>, or
<CODE>%</CODE>); if the prefix is omitted then <CODE>$</CODE> is assumed. <CODE>varname</CODE> is
followed by a value, in the case of a scalar, or by one or more values
in the case of a list or hash.  For example:
<PRE>
    # Set a global variable $dbh containing the database handle
    $interp-&gt;set_global(dbh =&gt; DBI-&gt;connect(...));</PRE>
<PRE>
    # Set a global hash %session from a local hash
    $interp-&gt;set_global('%session', %s);</PRE>
<P>The global is set in the package that components run in: usually
<CODE>HTML::Mason::Commands</CODE>, although this can be overridden via the
<A HREF="Compiler.html#in_package">Compiler's in_package</A> parameter.
The lines above, for example, are equivalent to:</P>
<PRE>
    $HTML::Mason::Commands::dbh = DBI-&gt;connect(...);
    %HTML::Mason::Commands::session = %s;</PRE>
<P>assuming that <CODE>in_package</CODE> has not been changed.</P>
<P>Any global that you set should also be registered with the
<A HREF="Compiler.html#allow_globals">Compiler's allow_globals</A>
parameter; otherwise you'll get warnings from <CODE>strict</CODE>.</P>
<a name="item_comp_exists"></a><P></P>
<DT><STRONG><A NAME="item_comp_exists">comp_exists (path)</A></STRONG><BR>
<DD>
Given an <EM>absolute</EM> component path, this method returns a boolean
value indicating whether or not a component exists for that path.
<a name="item_make_component"></a><P></P>
<DT><STRONG><A NAME="item_make_component">make_component (comp_source =&gt; ... )</A></STRONG><BR>
<DD>
<DT><STRONG>make_component (comp_file =&gt; ... )</STRONG><BR>
<DD>
This method compiles Mason component source code and returns a
Component object.  The source may be passed in as a string in <CODE>comp_source</CODE>,
or as a filename in <CODE>comp_file</CODE>.  When using <CODE>comp_file</CODE>, the
filename is specified as a path on the file system, not as a path
relative to Mason's component root (see 
<A HREF="Request.html#fetch_comp">Request-&gt;fetch_comp</A> for that).
<P>If Mason encounters an error during processing, an exception will be thrown.</P>
<P>Example of usage:</P>
<PRE>
    # Make an anonymous component
    my $anon_comp =
      eval { $interp-&gt;make_component
               ( comp_source =&gt; '&lt;%perl&gt;my $name = &quot;World&quot;;&lt;/%perl&gt;Hello &lt;% $name %&gt;!' ) };
    die $@ if $@;</PRE>
<PRE>
    $m-&gt;comp($anon_comp);</PRE>
<a name="item_load"></a><P></P>
<DT><STRONG><A NAME="item_load">load (path)</A></STRONG><BR>
<DD>
Returns the component object corresponding to an absolute component
<CODE>path</CODE>, or undef if none exists.
<a name="item_comp_root"></a><P></P>
<DT><STRONG><A NAME="item_comp_root">comp_root (comp_root)</A></STRONG><BR>
<DD>
This is a convenience method which simply calls the <A HREF="#item_comp_root"><CODE>comp_root</CODE></A>
method in the resolver object.  Obviously, if you are using a custom
resolver class which does not have a <A HREF="#item_comp_root"><CODE>comp_root</CODE></A> method, then this
convenience method will not work.
<P></P></DL>
<P>
<HR>
<H1><A NAME="see also">SEE ALSO</A></H1>
<P><A HREF="Mason.html">HTML::Mason</A>,
<A HREF="Admin.html">HTML::Mason::Admin</A>,
<A HREF="ApacheHandler.html">HTML::Mason::ApacheHandler</A></P>

</BODY>

</HTML>
