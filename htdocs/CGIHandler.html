<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>HTML::Mason::CGIHandler - Use Mason in a CGI environment</title>
<link rev="made" href="mailto:root@localhost" />
</head>

<body style="background-color: white">

<p><A NAME="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><A HREF="#name">NAME</a></li>
	<li><A HREF="#synopsis">SYNOPSIS</a></li>
	<li><A HREF="#description">DESCRIPTION</a></li>
	<ul>

		<li><A HREF="#html_mason_cgihandler_methods"><code>HTML::Mason::CGIHandler</code> Methods</a></li>
		<li><A HREF="#_r_methods">$r Methods</a></li>
		<li><A HREF="#added__m_methods">Added <code>$m</code> methods</a></li>
	</ul>

	<li><A HREF="#see_also">SEE ALSO</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<h1><A NAME="name">NAME</a></h1>
<p>HTML::Mason::CGIHandler - Use Mason in a CGI environment</p>
<p>
</p>
<hr />
<h1><A NAME="synopsis">SYNOPSIS</a></h1>
<p>In httpd.conf or .htaccess:</p>
<pre>
   Action html-mason /cgi-bin/mason_handler.cgi
   &lt;LocationMatch &quot;\.html$&quot;&gt;
    SetHandler html-mason
   &lt;/LocationMatch&gt;</pre>
<p>A script at /cgi-bin/mason_handler.pl :</p>
<pre>
   #!/usr/bin/perl
   use HTML::Mason::CGIHandler;
   
   my $h = HTML::Mason::CGIHandler-&gt;new
    (
     data_dir  =&gt; '/home/jethro/code/mason_data',
     allow_globals =&gt; [qw(%session $u)],
    );
   
   $h-&gt;handle_request;</pre>
<p>A .html component somewhere in the web server's document root:</p>
<pre>
   &lt;%args&gt;
    $mood =&gt; 'satisfied'
   &lt;/%args&gt;
   % $r-&gt;header_out(Location =&gt; &quot;<a href="http://blahblahblah.com/moodring/">http://blahblahblah.com/moodring/</a>$mood.html&quot;);
   ...</pre>
<p>
</p>
<hr />
<h1><A NAME="description">DESCRIPTION</a></h1>
<p>This module lets you execute Mason components in a CGI environment.
It lets you keep your top-level components in the web server's
document root, using regular component syntax and without worrying
about the particular details of invoking Mason on each request.</p>
<p>If you want to use Mason components from <em>within</em> a regular CGI
script (or any other Perl program, for that matter), then you don't
need this module.  You can simply follow the directions in
the <A HREF="Admin.html#using_mason_from_a_standalone_sc">Using Mason from a standalone script</a> section of the administrator's manual.</p>
<p>This module also provides an <code>$r</code> request object for use inside
components, similar to the Apache request object under
<code>HTML::Mason::ApacheHandler</code>, but limited in functionality.  Please
note that we aim to replicate the <code>mod_perl</code> functionality as closely
as possible - if you find differences, do <em>not</em> depend on them to
stay different.  We may fix them in a future release.  Also, if you
need some missing functionality in <code>$r</code>, let us know, we might be
able to provide it.</p>
<p>Finally, this module alters the <code>HTML::Mason::Request</code> object <code>$m</code> to
provide direct access to the CGI query, should such access be necessary.</p>
<p>
</p>
<h2><A NAME="html_mason_cgihandler_methods"><code>HTML::Mason::CGIHandler</code> Methods</a></h2>
<ul>
<li><strong><A NAME="item_new"><code>new()</code></a></strong><br />
</li>
Creates a new handler.  Accepts any parameter that the Interpreter
accepts.
<p>If no <code>comp_root</code> parameter is passed to <A HREF="#item_new"><code>new()</code></a>, the component root
will be <code>$ENV{DOCUMENT_ROOT}</code>.</p>
<p></p>
<li><strong><A NAME="item_handle_request"><code>handle_request()</code></a></strong><br />
</li>
Handles the current request, reading input from <code>$ENV{QUERY_STRING}</code>
or <code>STDIN</code> and sending headers and component output to <code>STDOUT</code>.
This method doesn't accept any parameters.  The initial component
will be the one specified in <code>$ENV{PATH_INFO}</code>.
<p></p>
<li><strong><A NAME="item_handle_comp"><code>handle_comp()</code></a></strong><br />
</li>
Like <A HREF="#item_handle_request"><code>handle_request()</code></a>, but the first (only) parameter is a
component path or component object.  This is useful within a
traditional CGI environment, in which you're essentially using Mason
as a templating language but not an application server.
<p><code>handle_component()</code> will create a CGI query object, parse the query
parameters, and send the HTTP header and component output to STDOUT.
If you want to handle those parts yourself, see
the <A HREF="Admin.html#using_mason_from_a_standalone_sc">Using Mason from a standalone script</a> section of the administrator's manual.</p>
<p></p>
<li><strong><A NAME="item_handle_cgi_object"><code>handle_cgi_object()</code></a></strong><br />
</li>
Also like <A HREF="#item_handle_request"><code>handle_request()</code></a>, but this method takes only a CGI object
as its parameter.  This can be quite useful if you want to use this
module with CGI::Fast.
<p>The component path will be the value of the CGI object's
<code>path_info()</code> method.</p>
<p></p>
<li><strong><A NAME="item_request_args"><code>request_args()</code></a></strong><br />
</li>
Given an <code>HTML::Mason::FakeApache</code> object, this method is expected to
return a hash containing the arguments to be passed to the component.
It is a separate method in order to make it easily overrideable in a
subclass.
<p></p>
<li><strong><A NAME="item_interp"><code>interp()</code></a></strong><br />
</li>
Returns the Mason Interpreter associated with this handler.  The
Interpreter lasts for the entire lifetime of the handler.
<p></p></ul>
<p>
</p>
<h2><A NAME="_r_methods">$r Methods</a></h2>
<ul>
<li><strong><A NAME="item_header_out"><code>header_out()</code></a></strong><br />
</li>
This works much like the <code>Apache</code> method of the same name.  When
passed the name of a header, returns the value of the given outgoing
header.  When passed a name and a value, sets the value of the header.
Setting the header to <code>undef</code> will actually <em>unset</em> the header
(instead of setting its value to <code>undef</code>), removing it from the table
of headers that will be sent to the client.
<p>The headers are eventually passed to the <code>CGI</code> module's <code>header()</code>
method.</p>
<p>One header currently gets special treatment - if you set a <code>Location</code>
header, you'll cause the <code>CGI</code> module's <code>redirect()</code> method to be
used instead of the <code>header()</code> method.  This means that in order to
do a redirect, all you need to do is:</p>
<pre>
 $r-&gt;header_out(Location =&gt; '<a href="http://redirect.to/here">http://redirect.to/here</a>');</pre>
<p>You may be happier using the <code>$m-&gt;redirect</code> method, though,
because it hides most of the complexities of sending headers and
getting the status code right.</p>
<p></p>
<li><strong><A NAME="item_content_type"><code>content_type()</code></a></strong><br />
</li>
When passed an argument, sets the content type of the current request
to the value of the argument.  Use this method instead of setting a
<code>Content-Type</code> header directly with <A HREF="#item_header_out"><code>header_out()</code></a>.  Like
<A HREF="#item_header_out"><code>header_out()</code></a>, setting the content type to <code>undef</code> will remove any
content type set previously.
<p>When called without arguments, returns the value set by a previous
call to <A HREF="#item_content_type"><code>content_type()</code></a>.  The behavior when <A HREF="#item_content_type"><code>content_type()</code></a> hasn't
already been set is undefined - currently it returns <code>undef</code>.</p>
<p>If no content type is set during the request, the default MIME type
<code>text/html</code> will be used.</p>
<p></p>
<li><strong><A NAME="item_http_header"><code>http_header()</code></a></strong><br />
</li>
This method returns the outgoing headers as a string, suitable for
sending to the client.
<p></p>
<li><strong><A NAME="item_params"><code>params()</code></a></strong><br />
</li>
This method returns a hash containing the parameters sent by the
client.  Multiple parameters of the same name are represented by array
references.  If both POST and query string arguments were submitted,
these will be merged together.
<p></p></ul>
<p>
</p>
<h2><A NAME="added__m_methods">Added <code>$m</code> methods</a></h2>
<p>The <code>$m</code> object provided in components has all the functionality of
the regular <code>HTML::Mason::Request</code> object <code>$m</code>, and the following:</p>
<ul>
<li><strong><A NAME="item_cgi_object"><code>cgi_object()</code></a></strong><br />
</li>
Returns the current <code>CGI</code> request object.  This is handy for
processing cookies or perhaps even doing HTML generation (but is that
<em>really</em> what you want to do?).  If you pass an argument to this
method, you can set the request object to the argument passed.  Use
this with care, as it may affect components called after the current
one (they may check the content length of the request, for example).
<p>Note that the ApacheHandler class (for using Mason under mod_perl)
also provides a <A HREF="#item_cgi_object"><code>cgi_object()</code></a> method that does the same thing as
this one.  This makes it easier to write components that function
equally well under CGIHandler and ApacheHandler.</p>
<p></p>
<li><strong><A NAME="item_cgi_request">cgi_request</a></strong><br />
</li>
Returns the object that is used to emulate Apache's request object.
In other words, this is the object that <code>$r</code> is set to when you use
this class.
<p></p></ul>
<p>
</p>
<hr />
<h1><A NAME="see_also">SEE ALSO</a></h1>
<p><a HREF="Mason.html">HTML::Mason</a>,
<a HREF="Admin.html">HTML::Mason::Admin</a>,
<a HREF="ApacheHandler.html">HTML::Mason::ApacheHandler</a></p>

</body>

</html>
